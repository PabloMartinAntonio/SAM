
> ui\ingest.py:14:def run_import_from_folder(config_path: str, input_dir: str, notas: str = "UI import") -> int:
  ui\ingest.py:15:    """
  ui\ingest.py:16:    Importa todos los archivos .txt de una carpeta a la BD
  ui\ingest.py:17:    
  ui\ingest.py:18:    Args:
  ui\ingest.py:19:        config_path: Ruta al config.ini
  ui\ingest.py:20:        input_dir: Directorio con archivos .txt
  ui\ingest.py:21:        notas: Notas para la ejecución
  ui\ingest.py:22:    
  ui\ingest.py:23:    Returns:
  ui\ingest.py:24:        ejecucion_id creado
  ui\ingest.py:25:    
  ui\ingest.py:26:    Raises:
  ui\ingest.py:27:        Exception si falla la importación
  ui\ingest.py:28:    """
  ui\ingest.py:29:    try:
  ui\ingest.py:30:        cfg = load_config(config_path)
  ui\ingest.py:31:        conn = get_conn(cfg)
  ui\ingest.py:32:        
  ui\ingest.py:33:        logger.info(f"Iniciando importación desde carpeta: {input_dir}")
  ui\ingest.py:34:        ejecucion_id, inserted_count = ingest_dir(conn, input_dir, notas)
  ui\ingest.py:35:        
  ui\ingest.py:36:        conn.close()
  ui\ingest.py:37:        
  ui\ingest.py:38:        if ejecucion_id:
  ui\ingest.py:39:            logger.info(f"Importación exitosa: ejecucion_id={ejecucion_id}, archivos={inserted_count}")
  ui\ingest.py:40:            return ejecucion_id
  ui\ingest.py:41:        else:
  ui\ingest.py:42:            raise Exception("Error en ingest_dir: no se pudo crear ejecución")
  ui\ingest.py:43:    
  ui\ingest.py:44:    except Exception as e:
  ui\ingest.py:45:        logger.error(f"Error importando desde carpeta: {e}")
  ui\ingest.py:46:        raise
  ui\ingest.py:47:
  ui\ingest.py:48:
> ui\ingest.py:49:def run_import_from_files(config_path: str, files: List[str], notas: str = "UI import (archivos)") -> int:
  ui\ingest.py:50:    """
  ui\ingest.py:51:    Importa archivos específicos a la BD creando una ejecución temporal
  ui\ingest.py:52:    
  ui\ingest.py:53:    Args:
  ui\ingest.py:54:        config_path: Ruta al config.ini
  ui\ingest.py:55:        files: Lista de rutas absolutas a archivos
  ui\ingest.py:56:        notas: Notas para la ejecución
  ui\ingest.py:57:    
  ui\ingest.py:58:    Returns:
  ui\ingest.py:59:        ejecucion_id creado
  ui\ingest.py:60:    
  ui\ingest.py:61:    Raises:
  ui\ingest.py:62:        Exception si falla la importación
  ui\ingest.py:63:    """
  ui\ingest.py:64:    if not files:
  ui\ingest.py:65:        raise ValueError("No se proporcionaron archivos para importar")
  ui\ingest.py:66:    
  ui\ingest.py:67:    try:
  ui\ingest.py:68:        cfg = load_config(config_path)
  ui\ingest.py:69:        conn = get_conn(cfg)
  ui\ingest.py:70:        cursor = conn.cursor()
  ui\ingest.py:71:        
  ui\ingest.py:72:        # Crear ejecución
  ui\ingest.py:73:        input_dir_info = f"{len(files)} archivos seleccionados"
  ui\ingest.py:74:        cursor.execute(
  ui\ingest.py:75:            "INSERT INTO sa_ejecuciones (notas, input_dir) VALUES (%s, %s)",
  ui\ingest.py:76:            (notas, input_dir_info)
  ui\ingest.py:77:        )
  ui\ingest.py:78:        ejecucion_id = cursor.lastrowid
  ui\ingest.py:79:        
  ui\ingest.py:80:        logger.info(f"Creada ejecución {ejecucion_id} para {len(files)} archivos")
  ui\ingest.py:81:        
  ui\ingest.py:82:        # Insertar cada archivo
  ui\ingest.py:83:        inserted_count = 0
  ui\ingest.py:84:        for file_path in files:
  ui\ingest.py:85:            try:
  ui\ingest.py:86:                # Leer archivo
  ui\ingest.py:87:                raw_text = ''
  ui\ingest.py:88:                try:
  ui\ingest.py:89:                    with open(file_path, 'r', encoding='utf-8') as f:
  ui\ingest.py:90:                        raw_text = f.read()
  ui\ingest.py:91:                except UnicodeDecodeError:
  ui\ingest.py:92:                    with open(file_path, 'r', encoding='latin-1') as f:
  ui\ingest.py:93:                        raw_text = f.read()
  ui\ingest.py:94:                    logger.warning(f"Fallback a latin-1 para {file_path}")
  ui\ingest.py:95:                
  ui\ingest.py:96:                # Insertar conversación
  ui\ingest.py:97:                filename = os.path.basename(file_path)
  ui\ingest.py:98:                cursor.execute(
  ui\ingest.py:99:                    """
  ui\ingest.py:100:                    INSERT INTO sa_conversaciones 
  ui\ingest.py:101:                    (ejecucion_id, conversacion_id, raw_path, raw_text, total_turnos)
  ui\ingest.py:102:                    VALUES (%s, %s, %s, %s, %s)
  ui\ingest.py:103:                    """,
  ui\ingest.py:104:                    (ejecucion_id, filename, file_path, raw_text, 0)
  ui\ingest.py:105:                )
  ui\ingest.py:106:                inserted_count += 1
  ui\ingest.py:107:                
  ui\ingest.py:108:            except Exception as e:
  ui\ingest.py:109:                logger.error(f"Error procesando {file_path}: {e}")
  ui\ingest.py:110:                continue
  ui\ingest.py:111:        
  ui\ingest.py:112:        conn.commit()
  ui\ingest.py:113:        cursor.close()
  ui\ingest.py:114:        conn.close()
  ui\ingest.py:115:        
  ui\ingest.py:116:        logger.info(f"Importación exitosa: ejecucion_id={ejecucion_id}, archivos={inserted_count}/{len(files)}")
  ui\ingest.py:117:        
  ui\ingest.py:118:        if inserted_count == 0:
  ui\ingest.py:119:            raise Exception("No se pudo importar ningún archivo")
  ui\ingest.py:120:        
  ui\ingest.py:121:        return ejecucion_id
  ui\ingest.py:122:    
  ui\ingest.py:123:    except Exception as e:
  ui\ingest.py:124:        logger.error(f"Error importando archivos: {e}")
  ui\ingest.py:125:        raise
> ui\app.py:12:from ui.views_deepseek import DeepSeekView
  ui\app.py:13:import ui.services as services
  ui\app.py:14:
  ui\app.py:15:# Configurar logging
  ui\app.py:16:logging.basicConfig(
  ui\app.py:17:    level=logging.INFO,
  ui\app.py:18:    format="[%(asctime)s] %(name)s - %(levelname)s - %(message)s",
  ui\app.py:19:    datefmt="%Y-%m-%d %H:%M:%S"
  ui\app.py:20:)
  ui\app.py:21:
  ui\app.py:22:logger = logging.getLogger(__name__)
  ui\app.py:23:
  ui\app.py:24:
  ui\app.py:25:class SpeechAnalyticsApp:
  ui\app.py:26:    """Aplicación principal de Speech Analytics UI"""
  ui\app.py:27:    
  ui\app.py:28:    def __init__(self):
  ui\app.py:29:        self.root = tk.Tk()
  ui\app.py:30:        self.root.title("Speech Analytics - Dashboard")
  ui\app.py:31:        self.root.geometry("1200x800")
  ui\app.py:32:        
  ui\app.py:33:        # Maximizar ventana por defecto
  ui\app.py:34:        try:
  ui\app.py:35:            self.root.state('zoomed')  # Windows
  ui\app.py:36:        except:
  ui\app.py:37:            try:
  ui\app.py:38:                self.root.attributes('-zoomed', True)  # Fallback
  ui\app.py:39:            except:
  ui\app.py:40:                pass  # Si falla, usar geometry normal
  ui\app.py:41:        
  ui\app.py:42:        # Configurar grid para que crezca
  ui\app.py:43:        self.root.grid_rowconfigure(0, weight=1)  # Main content
  ui\app.py:44:        self.root.grid_rowconfigure(1, weight=0)  # Status bar (altura fija)
  ui\app.py:45:        self.root.grid_columnconfigure(0, weight=1)
  ui\app.py:46:        
  ui\app.py:47:        self.db_conn = None
  ui\app.py:48:        self.db_status = "Desconectado"
  ui\app.py:49:        
  ui\app.py:50:        self._setup_styles()
  ui\app.py:51:        self._build_ui()
  ui\app.py:52:        self._connect_db()
  ui\app.py:53:        
  ui\app.py:54:        # Manejar cierre
  ui\app.py:55:        self.root.protocol("WM_DELETE_WINDOW", self._on_closing)
  ui\app.py:56:    
  ui\app.py:57:    def _setup_styles(self):
  ui\app.py:58:        """Configura estilos ttk"""
  ui\app.py:59:        style = ttk.Style()
  ui\app.py:60:        style.theme_use("clam")  # Tema más moderno
  ui\app.py:61:    
  ui\app.py:62:    def _build_ui(self):
  ui\app.py:63:        """Construye UI principal"""
  ui\app.py:64:        # Menu bar (opcional)
  ui\app.py:65:        menubar = tk.Menu(self.root)
  ui\app.py:66:        self.root.config(menu=menubar)
  ui\app.py:67:        
  ui\app.py:68:        # Menú archivo
  ui\app.py:69:        file_menu = tk.Menu(menubar, tearoff=0)
  ui\app.py:70:        menubar.add_cascade(label="Archivo", menu=file_menu)
  ui\app.py:71:        file_menu.add_command(label="Reconectar DB", command=self._reconnect_db)
  ui\app.py:72:        file_menu.add_separator()
  ui\app.py:73:        file_menu.add_command(label="Salir", command=self._on_closing)
  ui\app.py:74:        
  ui\app.py:75:        # Menú ayuda
  ui\app.py:76:        help_menu = tk.Menu(menubar, tearoff=0)
  ui\app.py:77:        menubar.add_cascade(label="Ayuda", menu=help_menu)
  ui\app.py:78:        help_menu.add_command(label="Acerca de", command=self._show_about)
  ui\app.py:79:        
  ui\app.py:80:        # Main container
  ui\app.py:81:        main_frame = ttk.Frame(self.root)
  ui\app.py:82:        main_frame.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)
  ui\app.py:83:        main_frame.grid_rowconfigure(0, weight=1)
  ui\app.py:84:        main_frame.grid_columnconfigure(0, weight=1)
  ui\app.py:85:        
  ui\app.py:86:        # Notebook con 3 pestañas
  ui\app.py:87:        self.notebook = ttk.Notebook(main_frame)
  ui\app.py:88:        self.notebook.grid(row=0, column=0, sticky='nsew')
  ui\app.py:89:        
  ui\app.py:90:        # Nota: las vistas se crearán después de conectar DB
  ui\app.py:91:        self.dashboard_view = None
  ui\app.py:92:        self.detalles_view = None
  ui\app.py:93:        self.aprendizaje_view = None
> ui\app.py:94:        self.deepseek_view = None
  ui\app.py:95:        
  ui\app.py:96:        # Status bar
  ui\app.py:97:        status_frame = ttk.Frame(self.root, relief=tk.SUNKEN, borderwidth=1)
  ui\app.py:98:        status_frame.grid(row=1, column=0, sticky='ew')
  ui\app.py:99:        
  ui\app.py:100:        self.status_label = ttk.Label(
  ui\app.py:101:            status_frame,
  ui\app.py:102:            text=f"Estado: {self.db_status}",
  ui\app.py:103:            anchor=tk.W
  ui\app.py:104:        )
  ui\app.py:105:        self.status_label.pack(side=tk.LEFT, padx=5, pady=2)
  ui\app.py:106:        
  ui\app.py:107:        self.version_label = ttk.Label(
  ui\app.py:108:            status_frame,
  ui\app.py:109:            text="v1.0.0",
  ui\app.py:110:            anchor=tk.E
  ui\app.py:111:        )
  ui\app.py:112:        self.version_label.pack(side=tk.RIGHT, padx=5, pady=2)
  ui\app.py:113:    
  ui\app.py:114:    def _connect_db(self):
  ui\app.py:115:        """Conecta a la base de datos"""
  ui\app.py:116:        try:
  ui\app.py:117:            logger.info("Conectando a base de datos...")
  ui\app.py:118:            self.db_conn = services.get_db_connection()
  ui\app.py:119:            
  ui\app.py:120:            # ✅ Verificar que la conexión es válida
  ui\app.py:121:            if self.db_conn is None:
  ui\app.py:122:                raise Exception("get_db_connection() retornó None")
  ui\app.py:123:            
  ui\app.py:124:            self.db_status = "Conectado"
  ui\app.py:125:            self._update_status()
  ui\app.py:126:            
  ui\app.py:127:            # ✅ Inyectar conexión ANTES de crear vistas
  ui\app.py:128:            self._inject_db_conn_into_views()
  ui\app.py:129:            
  ui\app.py:130:            # Crear vistas
  ui\app.py:131:            self._create_views()
  ui\app.py:132:            
  ui\app.py:133:            # ✅ Inyectar conexión DESPUÉS de crear vistas (garantía)
  ui\app.py:134:            self._inject_db_conn_into_views()
  ui\app.py:135:            
  ui\app.py:136:            logger.info("Conexión exitosa")
  ui\app.py:137:        except Exception as e:
  ui\app.py:138:            logger.error(f"Error conectando a DB: {e}")
  ui\app.py:139:            self.db_status = f"Error: {str(e)[:50]}"
  ui\app.py:140:            self._update_status()
  ui\app.py:141:            
  ui\app.py:142:            messagebox.showerror(
  ui\app.py:143:                "Error de Conexión",
  ui\app.py:144:                f"No se pudo conectar a la base de datos:\n\n{e}\n\n"
  ui\app.py:145:                "Verifique config.ini y asegúrese de que MySQL esté corriendo."
  ui\app.py:146:            )
  ui\app.py:147:    
  ui\app.py:148:    def _reconnect_db(self):
  ui\app.py:149:        """Reconecta a la base de datos"""
  ui\app.py:150:        if self.db_conn:
  ui\app.py:151:            try:
  ui\app.py:152:                self.db_conn.close()
  ui\app.py:153:            except:
  ui\app.py:154:                pass
  ui\app.py:155:        
  ui\app.py:156:        self._connect_db()
  ui\app.py:157:    
  ui\app.py:158:    def _inject_db_conn_into_views(self):
  ui\app.py:159:        """Inyecta la conexión DB en todas las vistas existentes"""
  ui\app.py:160:        if self.db_conn is None:
  ui\app.py:161:            logger.warning("No se puede inyectar db_conn: conexión es None")
  ui\app.py:162:            return
  ui\app.py:163:    
  ui\app.py:164:        views = [
  ui\app.py:165:            ('dashboard_view', self.dashboard_view),
  ui\app.py:166:            ('detalles_view', self.detalles_view),
  ui\app.py:167:            ('aprendizaje_view', self.aprendizaje_view),
> ui\app.py:168:            ('deepseek_view', self.deepseek_view)
  ui\app.py:169:        ]
  ui\app.py:170:        
  ui\app.py:171:        for view_name, view_instance in views:
  ui\app.py:172:            if view_instance is not None:
  ui\app.py:173:                view_instance.db_conn = self.db_conn
  ui\app.py:174:                logger.debug(f"DB conn inyectada en {view_name}")
  ui\app.py:175:    
  ui\app.py:176:    def _create_views(self):
  ui\app.py:177:        """Crea las vistas del notebook"""
  ui\app.py:178:        if not self.db_conn:
  ui\app.py:179:            logger.warning("No se pueden crear vistas sin conexión DB")
  ui\app.py:180:            return
  ui\app.py:181:        
  ui\app.py:182:        # ✅ Verificar que la conexión sigue activa con SELECT 1
  ui\app.py:183:        try:
  ui\app.py:184:            cursor = self.db_conn.cursor()
  ui\app.py:185:            cursor.execute("SELECT 1")
  ui\app.py:186:            cursor.fetchone()
  ui\app.py:187:            cursor.close()
  ui\app.py:188:            logger.debug("Conexión DB verificada antes de crear vistas")
  ui\app.py:189:        except Exception as e:
  ui\app.py:190:            logger.error(f"Conexión DB no válida: {e}")
  ui\app.py:191:            messagebox.showerror("Error", f"Conexión DB no válida: {e}")
  ui\app.py:192:            return
  ui\app.py:193:        
  ui\app.py:194:        # Limpiar vistas existentes
  ui\app.py:195:        for tab in self.notebook.tabs():
  ui\app.py:196:            self.notebook.forget(tab)
  ui\app.py:197:        
  ui\app.py:198:        # Crear vistas con conexión válida...
  ui\app.py:199:        try:
  ui\app.py:200:            self.dashboard_view = DashboardView(self.notebook, self.db_conn)
  ui\app.py:201:            self.notebook.add(self.dashboard_view, text="📊 Dashboard")
  ui\app.py:202:            
  ui\app.py:203:            self.detalles_view = DetallesView(self.notebook, self.db_conn)
  ui\app.py:204:            self.notebook.add(self.detalles_view, text="🔍 Detalles")
  ui\app.py:205:            
  ui\app.py:206:            self.aprendizaje_view = AprendizajeView(self.notebook, self.db_conn)
  ui\app.py:207:            self.notebook.add(self.aprendizaje_view, text="✏️ Aprendizaje")
  ui\app.py:208:            
> ui\app.py:209:            self.deepseek_view = DeepSeekView(self.notebook, self.db_conn)
> ui\app.py:210:            self.notebook.add(self.deepseek_view, text="🤖 DeepSeek")
  ui\app.py:211:            
  ui\app.py:212:            logger.info("Vistas creadas exitosamente")
  ui\app.py:213:        except Exception as e:
  ui\app.py:214:            logger.error(f"Error creando vistas: {e}")
  ui\app.py:215:            messagebox.showerror("Error", f"Error creando vistas: {e}")
  ui\app.py:216:    
  ui\app.py:217:    def _update_status(self):
  ui\app.py:218:        """Actualiza barra de estado"""
  ui\app.py:219:        self.status_label.config(text=f"Estado: {self.db_status}")
  ui\app.py:220:    
  ui\app.py:221:    def _show_about(self):
  ui\app.py:222:        """Muestra diálogo Acerca de"""
  ui\app.py:223:        messagebox.showinfo(
  ui\app.py:224:            "Acerca de Speech Analytics",
  ui\app.py:225:            "Speech Analytics Dashboard v1.0.0\n\n"
  ui\app.py:226:            "Herramienta de análisis y corrección de clasificación de fases.\n\n"
  ui\app.py:227:            "Desarrollado con Python + Tkinter"
  ui\app.py:228:        )
  ui\app.py:229:    
  ui\app.py:230:    def _on_closing(self):
  ui\app.py:231:        """Handler de cierre de ventana"""
  ui\app.py:232:        if messagebox.askokcancel("Salir", "¿Desea cerrar la aplicación?"):
  ui\app.py:233:            if self.db_conn:
  ui\app.py:234:                try:
  ui\app.py:235:                    self.db_conn.close()
  ui\app.py:236:                    logger.info("Conexión DB cerrada")
  ui\app.py:237:                except Exception as e:
  ui\app.py:238:                    logger.error(f"Error cerrando DB: {e}")
  ui\app.py:239:            
  ui\app.py:240:            self.root.destroy()
  ui\app.py:241:    
  ui\app.py:242:    def run(self):
  ui\app.py:243:        """Inicia el loop principal de la aplicación"""
  ui\app.py:244:        logger.info("Iniciando Speech Analytics UI...")
  ui\app.py:245:        self.root.mainloop()
  ui\app.py:246:        logger.info("Aplicación cerrada")
> ui\models.py:47:    fase_conf: Optional[float] = None
  ui\models.py:48:    intent: Optional[str] = None
  ui\models.py:49:    intent_conf: Optional[float] = None
  ui\models.py:50:
  ui\models.py:51:@dataclass
  ui\models.py:52:class CorreccionTurno:
  ui\models.py:53:    """Corrección humana de un turno"""
  ui\models.py:54:    conversacion_pk: int
  ui\models.py:55:    turno_idx: int
  ui\models.py:56:    fase_nueva: str
  ui\models.py:57:    intent_nuevo: Optional[str] = None
  ui\models.py:58:    nota: Optional[str] = None
> ui\services.py:259:                    SUM(CASE WHEN t.fase IS NOT NULL AND TRIM(t.fase) != '' THEN 1 ELSE 0 END) as con_fase,
> ui\services.py:260:                    SUM(CASE WHEN t.fase IS NULL OR TRIM(t.fase) = '' THEN 1 ELSE 0 END) as sin_fase
  ui\services.py:261:                FROM sa_turnos t
  ui\services.py:262:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:263:                WHERE c.ejecucion_id = %s
  ui\services.py:264:            """, (ejecucion_id,))
  ui\services.py:265:            row = cur.fetchone()
  ui\services.py:266:            stats.total_turnos = row["total"]
  ui\services.py:267:            stats.turnos_con_fase = row["con_fase"]
  ui\services.py:268:            stats.turnos_sin_fase = row["sin_fase"]
  ui\services.py:269:            
  ui\services.py:270:            # Pendientes por confianza
  ui\services.py:271:            cur.execute(f"""
  ui\services.py:272:                SELECT COUNT(*) as pendientes
  ui\services.py:273:                FROM sa_turnos t
  ui\services.py:274:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:275:                WHERE c.ejecucion_id = %s
> ui\services.py:276:                  AND (t.fase IS NULL OR TRIM(t.fase) = '' 
> ui\services.py:277:                       OR t.fase_conf IS NULL OR t.fase_conf < {conf_threshold})
  ui\services.py:278:            """, (ejecucion_id,))
  ui\services.py:279:            stats.pendientes_por_conf = cur.fetchone()["pendientes"]
  ui\services.py:280:            
  ui\services.py:281:            # Distribución por fase
  ui\services.py:282:            cur.execute("""
> ui\services.py:283:                SELECT t.fase, COUNT(*) as count
  ui\services.py:284:                FROM sa_turnos t
  ui\services.py:285:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:286:                WHERE c.ejecucion_id = %s
> ui\services.py:287:                  AND t.fase IS NOT NULL AND TRIM(t.fase) != ''
> ui\services.py:288:                GROUP BY t.fase
  ui\services.py:289:                ORDER BY count DESC
  ui\services.py:290:            """, (ejecucion_id,))
  ui\services.py:291:            stats.dist_fase = [(r["fase"], r["count"]) for r in cur.fetchall()]
  ui\services.py:292:            
  ui\services.py:293:            # Distribución por fase_source
  ui\services.py:294:            cur.execute("""
  ui\services.py:295:                SELECT t.fase_source, COUNT(*) as count
  ui\services.py:296:                FROM sa_turnos t
  ui\services.py:297:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:298:                WHERE c.ejecucion_id = %s
  ui\services.py:299:                  AND t.fase_source IS NOT NULL
  ui\services.py:300:                GROUP BY t.fase_source
  ui\services.py:301:                ORDER BY count DESC
  ui\services.py:302:            """, (ejecucion_id,))
  ui\services.py:303:            stats.dist_fase_source = [(r["fase_source"], r["count"]) for r in cur.fetchall()]
  ui\services.py:304:            
  ui\services.py:305:            # Opcional: promesas
  ui\services.py:306:            if tabla_existe(conn, "sa_promesas_pago"):
  ui\services.py:307:                cur.execute("""
  ui\services.py:308:                    SELECT 
  ui\services.py:309:                        COUNT(*) as total,
  ui\services.py:310:                        SUM(CASE WHEN monto IS NOT NULL THEN 1 ELSE 0 END) as con_monto,
  ui\services.py:311:                        SUM(CASE WHEN monto IS NULL THEN 1 ELSE 0 END) as sin_monto
  ui\services.py:312:                    FROM sa_promesas_pago p
  ui\services.py:313:                    JOIN sa_conversaciones c ON c.conversacion_pk = p.conversacion_pk
  ui\services.py:314:                    WHERE c.ejecucion_id = %s
  ui\services.py:315:                """, (ejecucion_id,))
  ui\services.py:316:                row = cur.fetchone()
  ui\services.py:317:                if row:
  ui\services.py:318:                    stats.total_promesas = row["total"] or 0
  ui\services.py:319:                    stats.promesas_con_monto = row["con_monto"] or 0
  ui\services.py:320:                    stats.promesas_sin_monto = row["sin_monto"] or 0
  ui\services.py:321:    
  ui\services.py:322:    except Exception as e:
  ui\services.py:323:        logger.error(f"Error obteniendo stats para ejecucion_id={ejecucion_id}: {e}")
  ui\services.py:324:    
  ui\services.py:325:    return stats
  ui\services.py:326:
  ui\services.py:327:@with_reconnect
  ui\services.py:328:def stats_total(conn, ejecucion_ids: List[int], conf_threshold: float = 0.08) -> StatsEjecucion:
  ui\services.py:329:    """Obtiene estadísticas agregadas para múltiples ejecuciones"""
  ui\services.py:330:    conn = ensure_conn(conn)
  ui\services.py:331:    stats = StatsEjecucion(ejecucion_id=None)  # None = total
  ui\services.py:332:    
  ui\services.py:333:    if not ejecucion_ids:
  ui\services.py:334:        return stats
  ui\services.py:335:    
  ui\services.py:336:    placeholders = ",".join(["%s"] * len(ejecucion_ids))
  ui\services.py:337:    
  ui\services.py:338:    try:
  ui\services.py:339:        with get_cursor(conn) as cur:
  ui\services.py:340:            # Total conversaciones
  ui\services.py:341:            cur.execute(f"""
  ui\services.py:342:                SELECT COUNT(*) as total
  ui\services.py:343:                FROM sa_conversaciones
  ui\services.py:344:                WHERE ejecucion_id IN ({placeholders})
  ui\services.py:345:            """, tuple(ejecucion_ids))
  ui\services.py:346:            stats.total_convs = cur.fetchone()["total"]
  ui\services.py:347:            
  ui\services.py:348:            # Total turnos, con fase, sin fase
  ui\services.py:349:            cur.execute(f"""
  ui\services.py:350:                SELECT 
  ui\services.py:351:                    COUNT(*) as total,
> ui\services.py:352:                    SUM(CASE WHEN t.fase IS NOT NULL AND TRIM(t.fase) != '' THEN 1 ELSE 0 END) as con_fase,
> ui\services.py:353:                    SUM(CASE WHEN t.fase IS NULL OR TRIM(t.fase) = '' THEN 1 ELSE 0 END) as sin_fase
  ui\services.py:354:                FROM sa_turnos t
  ui\services.py:355:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:356:                WHERE c.ejecucion_id IN ({placeholders})
  ui\services.py:357:            """, tuple(ejecucion_ids))
  ui\services.py:358:            row = cur.fetchone()
  ui\services.py:359:            stats.total_turnos = row["total"]
  ui\services.py:360:            stats.turnos_con_fase = row["con_fase"]
  ui\services.py:361:            stats.turnos_sin_fase = row["sin_fase"]
  ui\services.py:362:            
  ui\services.py:363:            # Pendientes por confianza
  ui\services.py:364:            cur.execute(f"""
  ui\services.py:365:                SELECT COUNT(*) as pendientes
  ui\services.py:366:                FROM sa_turnos t
  ui\services.py:367:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:368:                WHERE c.ejecucion_id IN ({placeholders})
> ui\services.py:369:                  AND (t.fase IS NULL OR TRIM(t.fase) = '' 
> ui\services.py:370:                       OR t.fase_conf IS NULL OR t.fase_conf < {conf_threshold})
  ui\services.py:371:            """, tuple(ejecucion_ids))
  ui\services.py:372:            stats.pendientes_por_conf = cur.fetchone()["pendientes"]
  ui\services.py:373:            
  ui\services.py:374:            # Distribución por fase
  ui\services.py:375:            cur.execute(f"""
> ui\services.py:376:                SELECT t.fase, COUNT(*) as count
  ui\services.py:377:                FROM sa_turnos t
  ui\services.py:378:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:379:                WHERE c.ejecucion_id IN ({placeholders})
> ui\services.py:380:                  AND t.fase IS NOT NULL AND TRIM(t.fase) != ''
> ui\services.py:381:                GROUP BY t.fase
  ui\services.py:382:                ORDER BY count DESC
  ui\services.py:383:            """, tuple(ejecucion_ids))
  ui\services.py:384:            stats.dist_fase = [(r["fase"], r["count"]) for r in cur.fetchall()]
  ui\services.py:385:            
  ui\services.py:386:            # Distribución por fase_source
  ui\services.py:387:            cur.execute(f"""
  ui\services.py:388:                SELECT t.fase_source, COUNT(*) as count
  ui\services.py:389:                FROM sa_turnos t
  ui\services.py:390:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:391:                WHERE c.ejecucion_id IN ({placeholders})
  ui\services.py:392:                  AND t.fase_source IS NOT NULL
  ui\services.py:393:                GROUP BY t.fase_source
  ui\services.py:394:                ORDER BY count DESC
  ui\services.py:395:            """, tuple(ejecucion_ids))
  ui\services.py:396:            stats.dist_fase_source = [(r["fase_source"], r["count"]) for r in cur.fetchall()]
  ui\services.py:397:            
  ui\services.py:398:            # Opcional: promesas
  ui\services.py:399:            if tabla_existe(conn, "sa_promesas_pago"):
  ui\services.py:400:                cur.execute(f"""
  ui\services.py:401:                    SELECT 
  ui\services.py:402:                        COUNT(*) as total,
  ui\services.py:403:                        SUM(CASE WHEN monto IS NOT NULL THEN 1 ELSE 0 END) as con_monto,
  ui\services.py:404:                        SUM(CASE WHEN monto IS NULL THEN 1 ELSE 0 END) as sin_monto
  ui\services.py:405:                    FROM sa_promesas_pago p
  ui\services.py:406:                    JOIN sa_conversaciones c ON c.conversacion_pk = p.conversacion_pk
  ui\services.py:407:                    WHERE c.ejecucion_id IN ({placeholders})
  ui\services.py:408:                """, tuple(ejecucion_ids))
  ui\services.py:409:                row = cur.fetchone()
  ui\services.py:410:                if row:
  ui\services.py:411:                    stats.total_promesas = row["total"] or 0
  ui\services.py:412:                    stats.promesas_con_monto = row["con_monto"] or 0
  ui\services.py:413:                    stats.promesas_sin_monto = row["sin_monto"] or 0
  ui\services.py:414:    
  ui\services.py:415:    except Exception as e:
  ui\services.py:416:        logger.error(f"Error obteniendo stats totales: {e}")
  ui\services.py:417:    
  ui\services.py:418:    return stats
  ui\services.py:419:
  ui\services.py:420:@with_reconnect
  ui\services.py:421:def listar_conversaciones(conn, ejecucion_id: int, search: str = "", limit: int = 500) -> List[Conversacion]:
  ui\services.py:422:    """Lista conversaciones de una ejecución con búsqueda opcional"""
  ui\services.py:423:    conn = ensure_conn(conn)
  ui\services.py:424:    try:
  ui\services.py:425:        cols = get_available_conversaciones_columns(conn)
  ui\services.py:426:        has_conv_id = "conversacion_id" in cols
  ui\services.py:427:        
  ui\services.py:428:        with get_cursor(conn) as cur:
  ui\services.py:429:            if search and has_conv_id:
  ui\services.py:430:                cur.execute(f"""
  ui\services.py:431:                    SELECT conversacion_pk, conversacion_id, ejecucion_id
  ui\services.py:432:                    FROM sa_conversaciones
  ui\services.py:433:                    WHERE ejecucion_id = %s
  ui\services.py:434:                      AND conversacion_id LIKE %s
  ui\services.py:435:                    ORDER BY conversacion_pk DESC
  ui\services.py:436:                    LIMIT {limit}
  ui\services.py:437:                """, (ejecucion_id, f"%{search}%"))
  ui\services.py:438:            elif search:
  ui\services.py:439:                # Buscar por pk si no existe conversacion_id
  ui\services.py:440:                try:
  ui\services.py:441:                    pk_search = int(search)
  ui\services.py:442:                    cur.execute(f"""
  ui\services.py:443:                        SELECT conversacion_pk, ejecucion_id
  ui\services.py:444:                        FROM sa_conversaciones
  ui\services.py:445:                        WHERE ejecucion_id = %s
  ui\services.py:446:                          AND conversacion_pk = %s
  ui\services.py:447:                        LIMIT {limit}
  ui\services.py:448:                    """, (ejecucion_id, pk_search))
  ui\services.py:449:                except ValueError:
  ui\services.py:450:                    # No es número, retornar vacío
  ui\services.py:451:                    return []
  ui\services.py:452:            else:
  ui\services.py:453:                if has_conv_id:
  ui\services.py:454:                    cur.execute(f"""
  ui\services.py:455:                        SELECT conversacion_pk, conversacion_id, ejecucion_id
  ui\services.py:456:                        FROM sa_conversaciones
  ui\services.py:457:                        WHERE ejecucion_id = %s
  ui\services.py:458:                        ORDER BY conversacion_pk DESC
  ui\services.py:459:                        LIMIT {limit}
  ui\services.py:460:                    """, (ejecucion_id,))
  ui\services.py:461:                else:
  ui\services.py:462:                    cur.execute(f"""
  ui\services.py:463:                        SELECT conversacion_pk, ejecucion_id
  ui\services.py:464:                        FROM sa_conversaciones
  ui\services.py:465:                        WHERE ejecucion_id = %s
  ui\services.py:466:                        ORDER BY conversacion_pk DESC
  ui\services.py:467:                        LIMIT {limit}
  ui\services.py:468:                    """, (ejecucion_id,))
  ui\services.py:469:            
  ui\services.py:470:            rows = cur.fetchall()
  ui\services.py:471:            return [Conversacion(
  ui\services.py:472:                conversacion_pk=r["conversacion_pk"],
  ui\services.py:473:                conversacion_id=r.get("conversacion_id"),
  ui\services.py:474:                ejecucion_id=r["ejecucion_id"]
  ui\services.py:475:            ) for r in rows]
  ui\services.py:476:    
  ui\services.py:477:    except Exception as e:
  ui\services.py:478:        logger.error(f"Error listando conversaciones: {e}")
  ui\services.py:479:        return []
  ui\services.py:480:
  ui\services.py:481:@with_reconnect
  ui\services.py:482:def listar_turnos(conn, conversacion_pk: int) -> List[Turno]:
  ui\services.py:483:    """Lista turnos de una conversación"""
  ui\services.py:484:    conn = ensure_conn(conn)
  ui\services.py:485:    try:
  ui\services.py:486:        cols = get_available_turnos_columns(conn)
  ui\services.py:487:        
  ui\services.py:488:        # Construir SELECT dinámico con columnas disponibles
  ui\services.py:489:        base_cols = ["turno_pk", "conversacion_pk", "turno_idx"]
> ui\services.py:490:        optional_cols = ["speaker", "text", "fase", "fase_source", "fase_conf", "intent", "intent_conf"]
  ui\services.py:491:        select_cols = base_cols + [c for c in optional_cols if c in cols]
  ui\services.py:492:        
  ui\services.py:493:        with get_cursor(conn) as cur:
  ui\services.py:494:            cur.execute(f"""
  ui\services.py:495:                SELECT {", ".join(select_cols)}
  ui\services.py:496:                FROM sa_turnos
  ui\services.py:497:                WHERE conversacion_pk = %s
  ui\services.py:498:                ORDER BY turno_idx
  ui\services.py:499:            """, (conversacion_pk,))
  ui\services.py:500:            
  ui\services.py:501:            rows = cur.fetchall()
  ui\services.py:502:            return [Turno(
  ui\services.py:503:                turno_pk=r["turno_pk"],
  ui\services.py:504:                conversacion_pk=r["conversacion_pk"],
  ui\services.py:505:                turno_idx=r["turno_idx"],
  ui\services.py:506:                speaker=r.get("speaker"),
  ui\services.py:507:                text=r.get("text"),
  ui\services.py:508:                fase=r.get("fase"),
  ui\services.py:509:                fase_source=r.get("fase_source"),
> ui\services.py:510:                fase_conf=r.get("fase_conf"),
  ui\services.py:511:                intent=r.get("intent"),
  ui\services.py:512:                intent_conf=r.get("intent_conf")
  ui\services.py:513:            ) for r in rows]
  ui\services.py:514:    
  ui\services.py:515:    except Exception as e:
  ui\services.py:516:        logger.error(f"Error listando turnos: {e}")
  ui\services.py:517:        return []
  ui\services.py:518:
  ui\services.py:519:@with_reconnect
  ui\services.py:520:def listar_turnos_pendientes(conn, ejecucion_id: int, conf_threshold: float = 0.08, 
  ui\services.py:521:                             offset: int = 0, limit: int = 200) -> List[Turno]:
  ui\services.py:522:    """Lista turnos pendientes de clasificación con paginación"""
  ui\services.py:523:    conn = ensure_conn(conn)
  ui\services.py:524:    try:
  ui\services.py:525:        cols = get_available_turnos_columns(conn)
  ui\services.py:526:        
  ui\services.py:527:        base_cols = ["t.turno_pk", "t.conversacion_pk", "t.turno_idx"]
> ui\services.py:528:        optional_cols = ["speaker", "text", "fase", "fase_source", "fase_conf", "intent", "intent_conf"]
  ui\services.py:529:        select_cols = base_cols + [f"t.{c}" for c in optional_cols if c in cols]
  ui\services.py:530:        
  ui\services.py:531:        with get_cursor(conn) as cur:
  ui\services.py:532:            cur.execute(f"""
  ui\services.py:533:                SELECT {", ".join(select_cols)}
  ui\services.py:534:                FROM sa_turnos t
  ui\services.py:535:                JOIN sa_conversaciones c ON c.conversacion_pk = t.conversacion_pk
  ui\services.py:536:                WHERE c.ejecucion_id = %s
> ui\services.py:537:                  AND (t.fase IS NULL OR TRIM(t.fase) = '' 
> ui\services.py:538:                       OR t.fase_conf IS NULL OR t.fase_conf < {conf_threshold})
  ui\services.py:539:                ORDER BY t.conversacion_pk, t.turno_idx
  ui\services.py:540:                LIMIT {limit} OFFSET {offset}
  ui\services.py:541:            """, (ejecucion_id,))
  ui\services.py:542:            
  ui\services.py:543:            rows = cur.fetchall()
  ui\services.py:544:            return [Turno(
  ui\services.py:545:                turno_pk=r["turno_pk"],
  ui\services.py:546:                conversacion_pk=r["conversacion_pk"],
  ui\services.py:547:                turno_idx=r["turno_idx"],
  ui\services.py:548:                speaker=r.get("speaker"),
  ui\services.py:549:                text=r.get("text"),
  ui\services.py:550:                fase=r.get("fase"),
  ui\services.py:551:                fase_source=r.get("fase_source"),
> ui\services.py:552:                fase_conf=r.get("fase_conf"),
  ui\services.py:553:                intent=r.get("intent"),
  ui\services.py:554:                intent_conf=r.get("intent_conf")
  ui\services.py:555:            ) for r in rows]
  ui\services.py:556:    
  ui\services.py:557:    except Exception as e:
  ui\services.py:558:        logger.error(f"Error listando turnos pendientes: {e}")
  ui\services.py:559:        return []
  ui\services.py:560:
  ui\services.py:561:@with_reconnect
  ui\services.py:562:def aplicar_correccion_turno(conn, conversacion_pk: int, turno_idx: int, 
  ui\services.py:563:                             fase_nueva: str, intent_nuevo: Optional[str] = None,
  ui\services.py:564:                             commit: bool = True) -> bool:
  ui\services.py:565:    """Aplica corrección humana a un turno en la BD"""
  ui\services.py:566:    conn = ensure_conn(conn)
  ui\services.py:567:    try:
  ui\services.py:568:        cols = get_available_turnos_columns(conn)
  ui\services.py:569:        has_intent = "intent" in cols
  ui\services.py:570:        has_intent_conf = "intent_conf" in cols
  ui\services.py:571:        
  ui\services.py:572:        with get_cursor(conn, dictionary=False) as cur:
  ui\services.py:573:            if intent_nuevo and has_intent:
  ui\services.py:574:                if has_intent_conf:
  ui\services.py:575:                    cur.execute("""
  ui\services.py:576:                        UPDATE sa_turnos
> ui\services.py:577:                        SET fase = %s, fase_source = 'HUMAN', fase_conf = 1.0,
  ui\services.py:578:                            intent = %s, intent_conf = 1.0
  ui\services.py:579:                        WHERE conversacion_pk = %s AND turno_idx = %s
  ui\services.py:580:                    """, (fase_nueva, intent_nuevo, conversacion_pk, turno_idx))
  ui\services.py:581:                else:
  ui\services.py:582:                    cur.execute("""
  ui\services.py:583:                        UPDATE sa_turnos
> ui\services.py:584:                        SET fase = %s, fase_source = 'HUMAN', fase_conf = 1.0,
  ui\services.py:585:                            intent = %s
  ui\services.py:586:                        WHERE conversacion_pk = %s AND turno_idx = %s
  ui\services.py:587:                    """, (fase_nueva, intent_nuevo, conversacion_pk, turno_idx))
  ui\services.py:588:            else:
  ui\services.py:589:                cur.execute("""
  ui\services.py:590:                    UPDATE sa_turnos
> ui\services.py:591:                    SET fase = %s, fase_source = 'HUMAN', fase_conf = 1.0
  ui\services.py:592:                    WHERE conversacion_pk = %s AND turno_idx = %s
  ui\services.py:593:                """, (fase_nueva, conversacion_pk, turno_idx))
  ui\services.py:594:            
  ui\services.py:595:            if commit:
  ui\services.py:596:                conn.commit()
  ui\services.py:597:            
  ui\services.py:598:            return True
  ui\services.py:599:    
  ui\services.py:600:    except Exception as e:
  ui\services.py:601:        logger.error(f"Error aplicando corrección: {e}")
  ui\services.py:602:        conn.rollback()
  ui\services.py:603:        return False
  ui\services.py:604:
  ui\services.py:605:@with_reconnect
  ui\services.py:606:def get_fases_disponibles(conn) -> List[str]:
  ui\services.py:607:    """Obtiene lista de fases únicas existentes en la BD"""
  ui\services.py:608:    conn = ensure_conn(conn)
  ui\services.py:609:    try:
  ui\services.py:610:        with get_cursor(conn) as cur:
  ui\services.py:611:            cur.execute("""
  ui\services.py:612:                SELECT DISTINCT fase
  ui\services.py:613:                FROM sa_turnos
  ui\services.py:614:                WHERE fase IS NOT NULL AND TRIM(fase) != ''
  ui\services.py:615:                ORDER BY fase
  ui\services.py:616:            """)
  ui\services.py:617:            return [r["fase"] for r in cur.fetchall()]
  ui\services.py:618:    except Exception as e:
  ui\services.py:619:        logger.error(f"Error obteniendo fases: {e}")
  ui\services.py:620:        return []
  ui\services.py:621:
  ui\services.py:622:@with_reconnect
  ui\services.py:623:def get_turnos_context(conn, conversacion_pk: int, turno_idx: int, window: int = 3) -> List[Dict[str, Any]]:
  ui\services.py:624:    """Obtiene contexto de turnos (anteriores + seleccionado + posteriores)
  ui\services.py:625:    
  ui\services.py:626:    Args:
  ui\services.py:627:        conn: Conexión a BD
  ui\services.py:628:        conversacion_pk: PK de la conversación
  ui\services.py:629:        turno_idx: Índice del turno central
  ui\services.py:630:        window: Número de turnos antes y después (default: 3)
  ui\services.py:631:    
  ui\services.py:632:    Returns:
  ui\services.py:633:        Lista de dicts con turnos en rango [turno_idx-window, turno_idx+window]
  ui\services.py:634:    """
  ui\services.py:635:    conn = ensure_conn(conn)
  ui\services.py:636:    try:
  ui\services.py:637:        cols = get_available_turnos_columns(conn)
  ui\services.py:638:        
  ui\services.py:639:        # Construir SELECT con columnas disponibles y aliases estándar
  ui\services.py:640:        # Base: conversacion_pk, turno_idx
  ui\services.py:641:        select_parts = ["conversacion_pk", "turno_idx"]
  ui\services.py:642:        
  ui\services.py:643:        # Speaker: preferir 'speaker', 'hablante'
  ui\services.py:644:        if "speaker" in cols:
  ui\services.py:645:            select_parts.append("speaker")
  ui\services.py:646:        elif "hablante" in cols:
  ui\services.py:647:            select_parts.append("hablante AS speaker")
  ui\services.py:648:        else:
  ui\services.py:649:            select_parts.append("NULL AS speaker")
  ui\services.py:650:        
  ui\services.py:651:        # Texto: preferir 'text', 'texto', 'utterance', 'contenido'
  ui\services.py:652:        text_col = None
  ui\services.py:653:        for col in ["text", "texto", "utterance", "contenido"]:
  ui\services.py:654:            if col in cols:
  ui\services.py:655:                text_col = col
  ui\services.py:656:                break
  ui\services.py:657:        
  ui\services.py:658:        if text_col and text_col != "text":
  ui\services.py:659:            select_parts.append(f"{text_col} AS text")
  ui\services.py:660:        elif text_col:
  ui\services.py:661:            select_parts.append("text")
  ui\services.py:662:        else:
  ui\services.py:663:            select_parts.append("NULL AS text")
  ui\services.py:664:        
> ui\services.py:665:        # Fase, fase_source, fase_conf, intent
> ui\services.py:666:        for col in ["fase", "fase_source", "fase_conf", "intent", "intent_conf"]:
  ui\services.py:667:            if col in cols:
  ui\services.py:668:                select_parts.append(col)
  ui\services.py:669:            else:
  ui\services.py:670:                select_parts.append(f"NULL AS {col}")
  ui\services.py:671:        
  ui\services.py:672:        # Calcular rango
  ui\services.py:673:        from_idx = max(1, turno_idx - window)
  ui\services.py:674:        to_idx = turno_idx + window
  ui\services.py:675:        
  ui\services.py:676:        with get_cursor(conn) as cur:
  ui\services.py:677:            query = f"""
  ui\services.py:678:                SELECT {', '.join(select_parts)}
  ui\services.py:679:                FROM sa_turnos
  ui\services.py:680:                WHERE conversacion_pk = %s
  ui\services.py:681:                  AND turno_idx BETWEEN %s AND %s
  ui\services.py:682:                ORDER BY turno_idx
  ui\services.py:683:            """
  ui\services.py:684:            cur.execute(query, (conversacion_pk, from_idx, to_idx))
  ui\services.py:685:            return cur.fetchall()
  ui\services.py:686:    
  ui\services.py:687:    except Exception as e:
  ui\services.py:688:        logger.error(f"Error obteniendo contexto de turnos: {e}")
  ui\services.py:689:        return []
> ui\views_aprendizaje.py:497:            fase_conf = row.get("fase_conf")
  ui\views_aprendizaje.py:498:            text = row.get("text") or "(sin texto)"
  ui\views_aprendizaje.py:499:            
  ui\views_aprendizaje.py:500:            # Formatear confianza
> ui\views_aprendizaje.py:501:            conf_str = f"{fase_conf:.2f}" if fase_conf is not None else "N/A"
  ui\views_aprendizaje.py:502:            
  ui\views_aprendizaje.py:503:            # Header del turno
  ui\views_aprendizaje.py:504:            is_selected = (idx == selected_turno_idx)
  ui\views_aprendizaje.py:505:            header = f"[{idx}] {speaker} | {fase} | {conf_str} | {fase_source}\n"
  ui\views_aprendizaje.py:506:            
  ui\views_aprendizaje.py:507:            # Insertar header
  ui\views_aprendizaje.py:508:            start_pos = self.context_text.index(tk.INSERT)
  ui\views_aprendizaje.py:509:            self.context_text.insert(tk.INSERT, header)
  ui\views_aprendizaje.py:510:            end_pos = self.context_text.index(tk.INSERT)
  ui\views_aprendizaje.py:511:            
  ui\views_aprendizaje.py:512:            # Aplicar tag al header
  ui\views_aprendizaje.py:513:            if is_selected:
  ui\views_aprendizaje.py:514:                self.context_text.tag_add("selected", start_pos, end_pos)
  ui\views_aprendizaje.py:515:                selected_line = start_pos
  ui\views_aprendizaje.py:516:            else:
  ui\views_aprendizaje.py:517:                self.context_text.tag_add("header", start_pos, end_pos)
  ui\views_aprendizaje.py:518:            
  ui\views_aprendizaje.py:519:            # Insertar texto del turno
  ui\views_aprendizaje.py:520:            text_start = self.context_text.index(tk.INSERT)
  ui\views_aprendizaje.py:521:            self.context_text.insert(tk.INSERT, f"{text}\n")
  ui\views_aprendizaje.py:522:            text_end = self.context_text.index(tk.INSERT)
  ui\views_aprendizaje.py:523:            
  ui\views_aprendizaje.py:524:            # Aplicar tag al texto si es seleccionado
  ui\views_aprendizaje.py:525:            if is_selected:
  ui\views_aprendizaje.py:526:                self.context_text.tag_add("selected", text_start, text_end)
  ui\views_aprendizaje.py:527:            
  ui\views_aprendizaje.py:528:            # Aplicar tag por speaker (opcional)
  ui\views_aprendizaje.py:529:            speaker_lower = speaker.lower()
  ui\views_aprendizaje.py:530:            if "agent" in speaker_lower or "asesor" in speaker_lower:
  ui\views_aprendizaje.py:531:                self.context_text.tag_add("speaker_agent", text_start, text_end)
  ui\views_aprendizaje.py:532:            elif "client" in speaker_lower or "usuario" in speaker_lower:
  ui\views_aprendizaje.py:533:                self.context_text.tag_add("speaker_cliente", text_start, text_end)
  ui\views_aprendizaje.py:534:            
  ui\views_aprendizaje.py:535:            # Separador
  ui\views_aprendizaje.py:536:            if i < len(context_rows) - 1:
  ui\views_aprendizaje.py:537:                self.context_text.insert(tk.INSERT, "-" * 70 + "\n")
  ui\views_aprendizaje.py:538:        
  ui\views_aprendizaje.py:539:        # Scroll para hacer visible el turno seleccionado
  ui\views_aprendizaje.py:540:        if selected_line:
  ui\views_aprendizaje.py:541:            self.context_text.see(selected_line)
  ui\views_aprendizaje.py:542:    
  ui\views_aprendizaje.py:543:    def _update_buffer_label(self):
  ui\views_aprendizaje.py:544:        """Actualiza label de buffer"""
  ui\views_aprendizaje.py:545:        self.correcciones_label.config(text=f"Correcciones en buffer: {len(self.correcciones_buffer)}")
  ui\views_aprendizaje.py:546:    
  ui\views_aprendizaje.py:547:    def _schedule_queue_check(self):
  ui\views_aprendizaje.py:548:        """Revisa cola de tareas"""
  ui\views_aprendizaje.py:549:        try:
  ui\views_aprendizaje.py:550:            while True:
  ui\views_aprendizaje.py:551:                msg = self.task_queue.get_nowait()
  ui\views_aprendizaje.py:552:                self._process_queue_message(msg)
  ui\views_aprendizaje.py:553:        except queue.Empty:
  ui\views_aprendizaje.py:554:            pass
  ui\views_aprendizaje.py:555:        finally:
  ui\views_aprendizaje.py:556:            self.after(100, self._schedule_queue_check)
  ui\views_aprendizaje.py:557:    
  ui\views_aprendizaje.py:558:    def _process_queue_message(self, msg):
  ui\views_aprendizaje.py:559:        """Procesa mensajes de la cola"""
  ui\views_aprendizaje.py:560:        if msg[0] == "inicial_cargado":
  ui\views_aprendizaje.py:561:            self.ejecuciones = msg[1]
  ui\views_aprendizaje.py:562:            self.fases_disponibles = msg[2]
  ui\views_aprendizaje.py:563:            self._update_ejecuciones_combo()
  ui\views_aprendizaje.py:564:            self._update_fases_combo()
  ui\views_aprendizaje.py:565:        elif msg[0] == "pendientes_cargados":
  ui\views_aprendizaje.py:566:            self.turnos_pendientes = msg[1]
  ui\views_aprendizaje.py:567:            self._update_turnos_tree()
  ui\views_aprendizaje.py:568:        elif msg[0] == "contexto_cargado":
  ui\views_aprendizaje.py:569:            context_rows = msg[1]
  ui\views_aprendizaje.py:570:            turno = msg[2]
  ui\views_aprendizaje.py:571:            self.context_rows = context_rows
  ui\views_aprendizaje.py:572:            self._render_context_text(context_rows, turno.turno_idx)
  ui\views_aprendizaje.py:573:            self._update_turno_display(turno)
  ui\views_aprendizaje.py:574:        elif msg[0] == "correccion_aplicada":
  ui\views_aprendizaje.py:575:            messagebox.showinfo("Éxito", "Corrección aplicada a BD")
  ui\views_aprendizaje.py:576:            self.cargar_pendientes()  # Recargar lista
  ui\views_aprendizaje.py:577:        elif msg[0] == "buffer_aplicado":
  ui\views_aprendizaje.py:578:            count = msg[1]
  ui\views_aprendizaje.py:579:            messagebox.showinfo("Éxito", f"{count} correcciones aplicadas a BD")
  ui\views_aprendizaje.py:580:            self.correcciones_buffer.clear()
  ui\views_aprendizaje.py:581:            self._update_buffer_label()
  ui\views_aprendizaje.py:582:            self.cargar_pendientes()
  ui\views_aprendizaje.py:583:        elif msg[0] == "error":
  ui\views_aprendizaje.py:584:            messagebox.showerror("Error", msg[1])
  ui\views_aprendizaje.py:585:    
  ui\views_aprendizaje.py:586:    def _update_ejecuciones_combo(self):
  ui\views_aprendizaje.py:587:        """Actualiza combo de ejecuciones"""
  ui\views_aprendizaje.py:588:        values = [f"Ejecución {ej.ejecucion_id} ({ej.num_conversaciones} convs)"
  ui\views_aprendizaje.py:589:                 for ej in self.ejecuciones]
  ui\views_aprendizaje.py:590:        self.ejecucion_combo["values"] = values
  ui\views_aprendizaje.py:591:        if values:
  ui\views_aprendizaje.py:592:            self.ejecucion_combo.current(0)
  ui\views_aprendizaje.py:593:            self.ejecucion_actual = self.ejecuciones[0].ejecucion_id
  ui\views_aprendizaje.py:594:    
  ui\views_aprendizaje.py:595:    def _update_fases_combo(self):
  ui\views_aprendizaje.py:596:        """Actualiza combo de fases"""
  ui\views_aprendizaje.py:597:        self.fase_combo["values"] = self.fases_disponibles
  ui\views_aprendizaje.py:598:    
  ui\views_aprendizaje.py:599:    def _update_turnos_tree(self):
  ui\views_aprendizaje.py:600:        """Actualiza tree de turnos pendientes"""
  ui\views_aprendizaje.py:601:        # Limpiar
  ui\views_aprendizaje.py:602:        for item in self.turnos_tree.get_children():
  ui\views_aprendizaje.py:603:            self.turnos_tree.delete(item)
  ui\views_aprendizaje.py:604:        
  ui\views_aprendizaje.py:605:        # Llenar
  ui\views_aprendizaje.py:606:        for turno in self.turnos_pendientes:
  ui\views_aprendizaje.py:607:            preview = (turno.text or "")[:60]
  ui\views_aprendizaje.py:608:            if len(turno.text or "") > 60:
  ui\views_aprendizaje.py:609:                preview += "..."
  ui\views_aprendizaje.py:610:            
> ui\views_aprendizaje.py:611:            conf_str = f"{turno.fase_conf:.2f}" if turno.fase_conf is not None else "N/A"
  ui\views_aprendizaje.py:612:            
  ui\views_aprendizaje.py:613:            self.turnos_tree.insert(
  ui\views_aprendizaje.py:614:                "", tk.END,
  ui\views_aprendizaje.py:615:                values=(
  ui\views_aprendizaje.py:616:                    turno.conversacion_pk,
  ui\views_aprendizaje.py:617:                    turno.turno_idx,
  ui\views_aprendizaje.py:618:                    turno.speaker or "?",
  ui\views_aprendizaje.py:619:                    turno.fase or "(none)",
  ui\views_aprendizaje.py:620:                    conf_str,
  ui\views_aprendizaje.py:621:                    preview
  ui\views_aprendizaje.py:622:                )
  ui\views_aprendizaje.py:623:            )
> ui\views_deepseek.py:2:Vista DeepSeek: Editor de prompt + Configuración DeepSeek/DB
  ui\views_deepseek.py:3:"""
  ui\views_deepseek.py:4:import tkinter as tk
  ui\views_deepseek.py:5:from tkinter import ttk, messagebox, scrolledtext
  ui\views_deepseek.py:6:import logging
  ui\views_deepseek.py:7:from pathlib import Path
  ui\views_deepseek.py:8:import configparser
  ui\views_deepseek.py:9:
  ui\views_deepseek.py:10:logger = logging.getLogger(__name__)
  ui\views_deepseek.py:11:
  ui\views_deepseek.py:12:# Constantes
> ui\views_deepseek.py:13:PROMPT_FILE = Path("prompts/deepseek_prompt.txt")
  ui\views_deepseek.py:14:CONFIG_FILE = Path("config.ini")
  ui\views_deepseek.py:15:
  ui\views_deepseek.py:16:
> ui\views_deepseek.py:17:class DeepSeekView(ttk.Frame):
> ui\views_deepseek.py:18:    """Vista para configuración de DeepSeek y edición de prompts"""
  ui\views_deepseek.py:19:    
  ui\views_deepseek.py:20:    def __init__(self, parent, db_conn):
  ui\views_deepseek.py:21:        super().__init__(parent)
  ui\views_deepseek.py:22:        self.db_conn = db_conn
  ui\views_deepseek.py:23:        
> ui\views_deepseek.py:24:        # Variables de config DeepSeek
  ui\views_deepseek.py:25:        self.api_key_var = tk.StringVar()
  ui\views_deepseek.py:26:        self.base_url_var = tk.StringVar()
  ui\views_deepseek.py:27:        self.model_var = tk.StringVar()
  ui\views_deepseek.py:28:        self.temperature_var = tk.StringVar(value="0.7")
  ui\views_deepseek.py:29:        self.max_tokens_var = tk.StringVar(value="2048")
  ui\views_deepseek.py:30:        self.show_api_key_var = tk.BooleanVar(value=False)
  ui\views_deepseek.py:31:        
  ui\views_deepseek.py:32:        # Variables de config DB
  ui\views_deepseek.py:33:        self.db_host_var = tk.StringVar()
  ui\views_deepseek.py:34:        self.db_port_var = tk.StringVar()
  ui\views_deepseek.py:35:        self.db_user_var = tk.StringVar()
  ui\views_deepseek.py:36:        self.db_password_var = tk.StringVar()
  ui\views_deepseek.py:37:        self.db_database_var = tk.StringVar()
  ui\views_deepseek.py:38:        self.show_db_password_var = tk.BooleanVar(value=False)
  ui\views_deepseek.py:39:        
  ui\views_deepseek.py:40:        # Detectar sección DB automáticamente
  ui\views_deepseek.py:41:        self.db_section = self._detect_db_section()
  ui\views_deepseek.py:42:        
  ui\views_deepseek.py:43:        self._build_ui()
  ui\views_deepseek.py:44:        
  ui\views_deepseek.py:45:        # Cargar configs al inicio
  ui\views_deepseek.py:46:        self._cargar_prompt_inicial()
> ui\views_deepseek.py:47:        self._cargar_config_deepseek_inicial()
  ui\views_deepseek.py:48:        self._cargar_config_db_inicial()
  ui\views_deepseek.py:49:    
  ui\views_deepseek.py:50:    def _detect_db_section(self):
  ui\views_deepseek.py:51:        """Detecta automáticamente la sección DB en config.ini"""
  ui\views_deepseek.py:52:        if not CONFIG_FILE.exists():
  ui\views_deepseek.py:53:            return "mysql"
  ui\views_deepseek.py:54:        
  ui\views_deepseek.py:55:        config = configparser.ConfigParser()
  ui\views_deepseek.py:56:        config.read(CONFIG_FILE, encoding="utf-8")
  ui\views_deepseek.py:57:        
  ui\views_deepseek.py:58:        # Buscar sección con keys típicas de DB
  ui\views_deepseek.py:59:        for section in config.sections():
  ui\views_deepseek.py:60:            if config.has_option(section, "host") and \
  ui\views_deepseek.py:61:               (config.has_option(section, "database") or config.has_option(section, "db")):
  ui\views_deepseek.py:62:                logger.info(f"Detectada sección DB: [{section}]")
  ui\views_deepseek.py:63:                return section
  ui\views_deepseek.py:64:        
  ui\views_deepseek.py:65:        # No encontrada, usar mysql por defecto
  ui\views_deepseek.py:66:        logger.info("No se detectó sección DB, usando [mysql] por defecto")
  ui\views_deepseek.py:67:        return "mysql"
  ui\views_deepseek.py:68:    
  ui\views_deepseek.py:69:    def _build_ui(self):
  ui\views_deepseek.py:70:        """Construye la UI de la vista"""
  ui\views_deepseek.py:71:        # Main container con scrollbar
  ui\views_deepseek.py:72:        canvas = tk.Canvas(self, borderwidth=0)
  ui\views_deepseek.py:73:        scrollbar = ttk.Scrollbar(self, orient="vertical", command=canvas.yview)
  ui\views_deepseek.py:74:        scrollable_frame = ttk.Frame(canvas)
  ui\views_deepseek.py:75:        
  ui\views_deepseek.py:76:        scrollable_frame.bind(
  ui\views_deepseek.py:77:            "<Configure>",
  ui\views_deepseek.py:78:            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
  ui\views_deepseek.py:79:        )
  ui\views_deepseek.py:80:        
  ui\views_deepseek.py:81:        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
  ui\views_deepseek.py:82:        canvas.configure(yscrollcommand=scrollbar.set)
  ui\views_deepseek.py:83:        
  ui\views_deepseek.py:84:        canvas.pack(side="left", fill="both", expand=True)
  ui\views_deepseek.py:85:        scrollbar.pack(side="right", fill="y")
  ui\views_deepseek.py:86:        
  ui\views_deepseek.py:87:        # Contenido en scrollable_frame
  ui\views_deepseek.py:88:        main_frame = ttk.Frame(scrollable_frame, padding=10)
  ui\views_deepseek.py:89:        main_frame.pack(fill=tk.BOTH, expand=True)
  ui\views_deepseek.py:90:        
  ui\views_deepseek.py:91:        # =================================================================
  ui\views_deepseek.py:92:        # SECCIÓN 1: Editor de Prompt
  ui\views_deepseek.py:93:        # =================================================================
  ui\views_deepseek.py:94:        prompt_frame = ttk.LabelFrame(main_frame, text="📝 Editor de Prompt", padding=10)
  ui\views_deepseek.py:95:        prompt_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
  ui\views_deepseek.py:96:        
  ui\views_deepseek.py:97:        # Label con ruta del archivo
  ui\views_deepseek.py:98:        self.prompt_path_label = ttk.Label(
  ui\views_deepseek.py:99:            prompt_frame,
  ui\views_deepseek.py:100:            text=f"Archivo: {PROMPT_FILE}",
  ui\views_deepseek.py:101:            foreground="gray"
  ui\views_deepseek.py:102:        )
  ui\views_deepseek.py:103:        self.prompt_path_label.pack(anchor=tk.W, pady=(0, 5))
  ui\views_deepseek.py:104:        
  ui\views_deepseek.py:105:        # Text widget para el prompt
  ui\views_deepseek.py:106:        self.prompt_text = scrolledtext.ScrolledText(
  ui\views_deepseek.py:107:            prompt_frame,
  ui\views_deepseek.py:108:            height=15,
  ui\views_deepseek.py:109:            width=80,
  ui\views_deepseek.py:110:            wrap=tk.WORD,
  ui\views_deepseek.py:111:            font=("Consolas", 10)
  ui\views_deepseek.py:112:        )
  ui\views_deepseek.py:113:        self.prompt_text.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
  ui\views_deepseek.py:114:        
  ui\views_deepseek.py:115:        # Botones
  ui\views_deepseek.py:116:        prompt_btn_frame = ttk.Frame(prompt_frame)
  ui\views_deepseek.py:117:        prompt_btn_frame.pack(fill=tk.X)
  ui\views_deepseek.py:118:        
  ui\views_deepseek.py:119:        ttk.Button(
  ui\views_deepseek.py:120:            prompt_btn_frame,
  ui\views_deepseek.py:121:            text="📂 Cargar Prompt",
  ui\views_deepseek.py:122:            command=self._cargar_prompt
  ui\views_deepseek.py:123:        ).pack(side=tk.LEFT, padx=5)
  ui\views_deepseek.py:124:        
  ui\views_deepseek.py:125:        ttk.Button(
  ui\views_deepseek.py:126:            prompt_btn_frame,
  ui\views_deepseek.py:127:            text="💾 Guardar Prompt",
  ui\views_deepseek.py:128:            command=self._guardar_prompt
  ui\views_deepseek.py:129:        ).pack(side=tk.LEFT, padx=5)
  ui\views_deepseek.py:130:        
  ui\views_deepseek.py:131:        # =================================================================
> ui\views_deepseek.py:132:        # SECCIÓN 2: Configuración DeepSeek
  ui\views_deepseek.py:133:        # =================================================================
> ui\views_deepseek.py:134:        deepseek_frame = ttk.LabelFrame(main_frame, text="🤖 Configuración DeepSeek", padding=10)
> ui\views_deepseek.py:135:        deepseek_frame.pack(fill=tk.X, pady=(0, 10))
  ui\views_deepseek.py:136:        
  ui\views_deepseek.py:137:        # Grid para inputs
  ui\views_deepseek.py:138:        row = 0
  ui\views_deepseek.py:139:        
  ui\views_deepseek.py:140:        # API Key (enmascarado)
> ui\views_deepseek.py:141:        ttk.Label(deepseek_frame, text="API Key:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:142:        api_key_entry = ttk.Entry(
> ui\views_deepseek.py:143:            deepseek_frame,
  ui\views_deepseek.py:144:            textvariable=self.api_key_var,
  ui\views_deepseek.py:145:            show="*",
  ui\views_deepseek.py:146:            width=40
  ui\views_deepseek.py:147:        )
  ui\views_deepseek.py:148:        api_key_entry.grid(row=row, column=1, sticky=tk.EW, padx=5, pady=5)
  ui\views_deepseek.py:149:        
  ui\views_deepseek.py:150:        # Checkbox para mostrar API key
  ui\views_deepseek.py:151:        self.api_key_checkbox = ttk.Checkbutton(
> ui\views_deepseek.py:152:            deepseek_frame,
  ui\views_deepseek.py:153:            text="Mostrar",
  ui\views_deepseek.py:154:            variable=self.show_api_key_var,
  ui\views_deepseek.py:155:            command=self._toggle_api_key_visibility
  ui\views_deepseek.py:156:        )
  ui\views_deepseek.py:157:        self.api_key_checkbox.grid(row=row, column=2, sticky=tk.W, padx=5, pady=5)
  ui\views_deepseek.py:158:        self.api_key_entry = api_key_entry  # Guardar referencia
  ui\views_deepseek.py:159:        row += 1
  ui\views_deepseek.py:160:        
  ui\views_deepseek.py:161:        # Base URL
> ui\views_deepseek.py:162:        ttk.Label(deepseek_frame, text="Base URL:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:163:        ttk.Entry(
> ui\views_deepseek.py:164:            deepseek_frame,
  ui\views_deepseek.py:165:            textvariable=self.base_url_var,
  ui\views_deepseek.py:166:            width=40
  ui\views_deepseek.py:167:        ).grid(row=row, column=1, sticky=tk.EW, padx=5, pady=5)
  ui\views_deepseek.py:168:        row += 1
  ui\views_deepseek.py:169:        
  ui\views_deepseek.py:170:        # Model
> ui\views_deepseek.py:171:        ttk.Label(deepseek_frame, text="Model:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:172:        ttk.Entry(
> ui\views_deepseek.py:173:            deepseek_frame,
  ui\views_deepseek.py:174:            textvariable=self.model_var,
  ui\views_deepseek.py:175:            width=40
  ui\views_deepseek.py:176:        ).grid(row=row, column=1, sticky=tk.EW, padx=5, pady=5)
  ui\views_deepseek.py:177:        row += 1
  ui\views_deepseek.py:178:        
  ui\views_deepseek.py:179:        # Temperature
> ui\views_deepseek.py:180:        ttk.Label(deepseek_frame, text="Temperature:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:181:        ttk.Entry(
> ui\views_deepseek.py:182:            deepseek_frame,
  ui\views_deepseek.py:183:            textvariable=self.temperature_var,
  ui\views_deepseek.py:184:            width=20
  ui\views_deepseek.py:185:        ).grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)
  ui\views_deepseek.py:186:        row += 1
  ui\views_deepseek.py:187:        
  ui\views_deepseek.py:188:        # Max Tokens
> ui\views_deepseek.py:189:        ttk.Label(deepseek_frame, text="Max Tokens:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:190:        ttk.Entry(
> ui\views_deepseek.py:191:            deepseek_frame,
  ui\views_deepseek.py:192:            textvariable=self.max_tokens_var,
  ui\views_deepseek.py:193:            width=20
  ui\views_deepseek.py:194:        ).grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)
  ui\views_deepseek.py:195:        row += 1
  ui\views_deepseek.py:196:        
  ui\views_deepseek.py:197:        # Configurar expansión de columna
> ui\views_deepseek.py:198:        deepseek_frame.columnconfigure(1, weight=1)
  ui\views_deepseek.py:199:        
  ui\views_deepseek.py:200:        # Botones
> ui\views_deepseek.py:201:        deepseek_btn_frame = ttk.Frame(deepseek_frame)
> ui\views_deepseek.py:202:        deepseek_btn_frame.grid(row=row, column=0, columnspan=3, pady=(10, 0), sticky=tk.W)
  ui\views_deepseek.py:203:        
  ui\views_deepseek.py:204:        ttk.Button(
> ui\views_deepseek.py:205:            deepseek_btn_frame,
  ui\views_deepseek.py:206:            text="📂 Cargar Config",
> ui\views_deepseek.py:207:            command=self._cargar_config_deepseek
  ui\views_deepseek.py:208:        ).pack(side=tk.LEFT, padx=5)
  ui\views_deepseek.py:209:        
  ui\views_deepseek.py:210:        ttk.Button(
> ui\views_deepseek.py:211:            deepseek_btn_frame,
  ui\views_deepseek.py:212:            text="💾 Guardar Config",
> ui\views_deepseek.py:213:            command=self._guardar_config_deepseek
  ui\views_deepseek.py:214:        ).pack(side=tk.LEFT, padx=5)
  ui\views_deepseek.py:215:        
  ui\views_deepseek.py:216:        ttk.Button(
> ui\views_deepseek.py:217:            deepseek_btn_frame,
> ui\views_deepseek.py:218:            text="🔍 Probar DeepSeek",
> ui\views_deepseek.py:219:            command=self._probar_deepseek
  ui\views_deepseek.py:220:        ).pack(side=tk.LEFT, padx=5)
  ui\views_deepseek.py:221:        
  ui\views_deepseek.py:222:        # =================================================================
  ui\views_deepseek.py:223:        # SECCIÓN 3: Configuración DB
  ui\views_deepseek.py:224:        # =================================================================
  ui\views_deepseek.py:225:        db_frame = ttk.LabelFrame(main_frame, text="🗄️ Configuración Base de Datos", padding=10)
  ui\views_deepseek.py:226:        db_frame.pack(fill=tk.X, pady=(0, 10))
  ui\views_deepseek.py:227:        
  ui\views_deepseek.py:228:        # Label con sección detectada
  ui\views_deepseek.py:229:        ttk.Label(
  ui\views_deepseek.py:230:            db_frame,
  ui\views_deepseek.py:231:            text=f"Sección en config.ini: [{self.db_section}]",
  ui\views_deepseek.py:232:            foreground="gray"
  ui\views_deepseek.py:233:        ).grid(row=0, column=0, columnspan=3, sticky=tk.W, pady=(0, 10))
  ui\views_deepseek.py:234:        
  ui\views_deepseek.py:235:        # Grid para inputs
  ui\views_deepseek.py:236:        row = 1
  ui\views_deepseek.py:237:        
  ui\views_deepseek.py:238:        # Host
  ui\views_deepseek.py:239:        ttk.Label(db_frame, text="Host:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:240:        ttk.Entry(
  ui\views_deepseek.py:241:            db_frame,
  ui\views_deepseek.py:242:            textvariable=self.db_host_var,
  ui\views_deepseek.py:243:            width=40
  ui\views_deepseek.py:244:        ).grid(row=row, column=1, sticky=tk.EW, padx=5, pady=5)
  ui\views_deepseek.py:245:        row += 1
  ui\views_deepseek.py:246:        
  ui\views_deepseek.py:247:        # Port
  ui\views_deepseek.py:248:        ttk.Label(db_frame, text="Port:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:249:        ttk.Entry(
  ui\views_deepseek.py:250:            db_frame,
  ui\views_deepseek.py:251:            textvariable=self.db_port_var,
  ui\views_deepseek.py:252:            width=20
  ui\views_deepseek.py:253:        ).grid(row=row, column=1, sticky=tk.W, padx=5, pady=5)
  ui\views_deepseek.py:254:        row += 1
  ui\views_deepseek.py:255:        
  ui\views_deepseek.py:256:        # User
  ui\views_deepseek.py:257:        ttk.Label(db_frame, text="User:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:258:        ttk.Entry(
  ui\views_deepseek.py:259:            db_frame,
  ui\views_deepseek.py:260:            textvariable=self.db_user_var,
  ui\views_deepseek.py:261:            width=40
  ui\views_deepseek.py:262:        ).grid(row=row, column=1, sticky=tk.EW, padx=5, pady=5)
  ui\views_deepseek.py:263:        row += 1
  ui\views_deepseek.py:264:        
  ui\views_deepseek.py:265:        # Password (enmascarado)
  ui\views_deepseek.py:266:        ttk.Label(db_frame, text="Password:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:267:        db_password_entry = ttk.Entry(
  ui\views_deepseek.py:268:            db_frame,
  ui\views_deepseek.py:269:            textvariable=self.db_password_var,
  ui\views_deepseek.py:270:            show="*",
  ui\views_deepseek.py:271:            width=40
  ui\views_deepseek.py:272:        )
  ui\views_deepseek.py:273:        db_password_entry.grid(row=row, column=1, sticky=tk.EW, padx=5, pady=5)
  ui\views_deepseek.py:274:        
  ui\views_deepseek.py:275:        # Checkbox para mostrar password
  ui\views_deepseek.py:276:        self.db_password_checkbox = ttk.Checkbutton(
  ui\views_deepseek.py:277:            db_frame,
  ui\views_deepseek.py:278:            text="Mostrar",
  ui\views_deepseek.py:279:            variable=self.show_db_password_var,
  ui\views_deepseek.py:280:            command=self._toggle_db_password_visibility
  ui\views_deepseek.py:281:        )
  ui\views_deepseek.py:282:        self.db_password_checkbox.grid(row=row, column=2, sticky=tk.W, padx=5, pady=5)
  ui\views_deepseek.py:283:        self.db_password_entry = db_password_entry  # Guardar referencia
  ui\views_deepseek.py:284:        row += 1
  ui\views_deepseek.py:285:        
  ui\views_deepseek.py:286:        # Database
  ui\views_deepseek.py:287:        ttk.Label(db_frame, text="Database:").grid(row=row, column=0, sticky=tk.W, pady=5)
  ui\views_deepseek.py:288:        ttk.Entry(
  ui\views_deepseek.py:289:            db_frame,
  ui\views_deepseek.py:290:            textvariable=self.db_database_var,
  ui\views_deepseek.py:291:            width=40
  ui\views_deepseek.py:292:        ).grid(row=row, column=1, sticky=tk.EW, padx=5, pady=5)
  ui\views_deepseek.py:293:        row += 1
  ui\views_deepseek.py:294:        
  ui\views_deepseek.py:295:        # Configurar expansión de columna
  ui\views_deepseek.py:296:        db_frame.columnconfigure(1, weight=1)
  ui\views_deepseek.py:297:        
  ui\views_deepseek.py:298:        # Botones
  ui\views_deepseek.py:299:        db_btn_frame = ttk.Frame(db_frame)
  ui\views_deepseek.py:300:        db_btn_frame.grid(row=row, column=0, columnspan=3, pady=(10, 0), sticky=tk.W)
  ui\views_deepseek.py:301:        
  ui\views_deepseek.py:302:        ttk.Button(
  ui\views_deepseek.py:303:            db_btn_frame,
  ui\views_deepseek.py:304:            text="📂 Cargar DB Config",
  ui\views_deepseek.py:305:            command=self._cargar_config_db
  ui\views_deepseek.py:306:        ).pack(side=tk.LEFT, padx=5)
  ui\views_deepseek.py:307:        
  ui\views_deepseek.py:308:        ttk.Button(
  ui\views_deepseek.py:309:            db_btn_frame,
  ui\views_deepseek.py:310:            text="💾 Guardar DB Config",
  ui\views_deepseek.py:311:            command=self._guardar_config_db
  ui\views_deepseek.py:312:        ).pack(side=tk.LEFT, padx=5)
  ui\views_deepseek.py:313:        
  ui\views_deepseek.py:314:        ttk.Button(
  ui\views_deepseek.py:315:            db_btn_frame,
  ui\views_deepseek.py:316:            text="🔌 Probar Conexión DB",
  ui\views_deepseek.py:317:            command=self._probar_conexion_db
  ui\views_deepseek.py:318:        ).pack(side=tk.LEFT, padx=5)
  ui\views_deepseek.py:319:    
  ui\views_deepseek.py:320:    # =================================================================
  ui\views_deepseek.py:321:    # MÉTODOS: Editor de Prompt
  ui\views_deepseek.py:322:    # =================================================================
  ui\views_deepseek.py:323:    
  ui\views_deepseek.py:324:    def _cargar_prompt_inicial(self):
  ui\views_deepseek.py:325:        """Carga el prompt al iniciar (si existe)"""
  ui\views_deepseek.py:326:        if PROMPT_FILE.exists():
  ui\views_deepseek.py:327:            try:
  ui\views_deepseek.py:328:                content = PROMPT_FILE.read_text(encoding="utf-8")
  ui\views_deepseek.py:329:                self.prompt_text.delete("1.0", tk.END)
  ui\views_deepseek.py:330:                self.prompt_text.insert("1.0", content)
  ui\views_deepseek.py:331:                logger.info(f"Prompt cargado desde {PROMPT_FILE}")
  ui\views_deepseek.py:332:            except Exception as e:
  ui\views_deepseek.py:333:                logger.warning(f"No se pudo cargar prompt inicial: {e}")
  ui\views_deepseek.py:334:    
  ui\views_deepseek.py:335:    def _cargar_prompt(self):
  ui\views_deepseek.py:336:        """Carga el prompt desde archivo"""
  ui\views_deepseek.py:337:        if not PROMPT_FILE.exists():
  ui\views_deepseek.py:338:            messagebox.showwarning(
  ui\views_deepseek.py:339:                "Archivo no encontrado",
> ui\views_deepseek.py:374:    # MÉTODOS: Configuración DeepSeek
  ui\views_deepseek.py:375:    # =================================================================
  ui\views_deepseek.py:376:    
> ui\views_deepseek.py:377:    def _cargar_config_deepseek_inicial(self):
> ui\views_deepseek.py:378:        """Carga config DeepSeek al iniciar"""
  ui\views_deepseek.py:379:        if not CONFIG_FILE.exists():
  ui\views_deepseek.py:380:            return
  ui\views_deepseek.py:381:        
  ui\views_deepseek.py:382:        try:
  ui\views_deepseek.py:383:            config = configparser.ConfigParser()
  ui\views_deepseek.py:384:            config.read(CONFIG_FILE, encoding="utf-8")
  ui\views_deepseek.py:385:            
> ui\views_deepseek.py:386:            if config.has_section("deepseek"):
> ui\views_deepseek.py:387:                self.api_key_var.set(config.get("deepseek", "api_key", fallback=""))
> ui\views_deepseek.py:388:                self.base_url_var.set(config.get("deepseek", "base_url", fallback=""))
> ui\views_deepseek.py:389:                self.model_var.set(config.get("deepseek", "model", fallback=""))
> ui\views_deepseek.py:390:                self.temperature_var.set(config.get("deepseek", "temperature", fallback="0.7"))
> ui\views_deepseek.py:391:                self.max_tokens_var.set(config.get("deepseek", "max_tokens", fallback="2048"))
  ui\views_deepseek.py:392:                
> ui\views_deepseek.py:393:                logger.info("Config DeepSeek cargada al iniciar")
  ui\views_deepseek.py:394:        except Exception as e:
> ui\views_deepseek.py:395:            logger.warning(f"No se pudo cargar config DeepSeek inicial: {e}")
  ui\views_deepseek.py:396:    
> ui\views_deepseek.py:397:    def _cargar_config_deepseek(self):
> ui\views_deepseek.py:398:        """Carga config DeepSeek desde config.ini"""
  ui\views_deepseek.py:399:        if not CONFIG_FILE.exists():
  ui\views_deepseek.py:400:            messagebox.showwarning(
  ui\views_deepseek.py:401:                "Archivo no encontrado",
  ui\views_deepseek.py:402:                f"El archivo {CONFIG_FILE} no existe.\n\n"
  ui\views_deepseek.py:403:                "Será creado al guardar la configuración."
  ui\views_deepseek.py:404:            )
  ui\views_deepseek.py:405:            return
  ui\views_deepseek.py:406:        
  ui\views_deepseek.py:407:        try:
  ui\views_deepseek.py:408:            config = configparser.ConfigParser()
  ui\views_deepseek.py:409:            config.read(CONFIG_FILE, encoding="utf-8")
  ui\views_deepseek.py:410:            
> ui\views_deepseek.py:411:            if not config.has_section("deepseek"):
  ui\views_deepseek.py:412:                messagebox.showwarning(
  ui\views_deepseek.py:413:                    "Sección no encontrada",
> ui\views_deepseek.py:414:                    "No se encontró la sección [deepseek] en config.ini.\n\n"
  ui\views_deepseek.py:415:                    "Será creada al guardar."
  ui\views_deepseek.py:416:                )
  ui\views_deepseek.py:417:                return
  ui\views_deepseek.py:418:            
> ui\views_deepseek.py:419:            self.api_key_var.set(config.get("deepseek", "api_key", fallback=""))
> ui\views_deepseek.py:420:            self.base_url_var.set(config.get("deepseek", "base_url", fallback=""))
> ui\views_deepseek.py:421:            self.model_var.set(config.get("deepseek", "model", fallback=""))
> ui\views_deepseek.py:422:            self.temperature_var.set(config.get("deepseek", "temperature", fallback="0.7"))
> ui\views_deepseek.py:423:            self.max_tokens_var.set(config.get("deepseek", "max_tokens", fallback="2048"))
  ui\views_deepseek.py:424:            
> ui\views_deepseek.py:425:            messagebox.showinfo("OK", "Configuración DeepSeek cargada correctamente")
> ui\views_deepseek.py:426:            logger.info("Config DeepSeek cargada desde config.ini")
  ui\views_deepseek.py:427:        except Exception as e:
> ui\views_deepseek.py:428:            logger.error(f"Error cargando config DeepSeek: {e}")
  ui\views_deepseek.py:429:            messagebox.showerror("Error", f"Error cargando configuración:\n{e}")
  ui\views_deepseek.py:430:    
> ui\views_deepseek.py:431:    def _guardar_config_deepseek(self):
> ui\views_deepseek.py:432:        """Guarda config DeepSeek a config.ini"""
  ui\views_deepseek.py:433:        try:
  ui\views_deepseek.py:434:            # Leer config existente (preservar otras secciones)
  ui\views_deepseek.py:435:            config = configparser.ConfigParser()
  ui\views_deepseek.py:436:            if CONFIG_FILE.exists():
  ui\views_deepseek.py:437:                config.read(CONFIG_FILE, encoding="utf-8")
  ui\views_deepseek.py:438:            
> ui\views_deepseek.py:439:            # Crear/actualizar sección deepseek
> ui\views_deepseek.py:440:            if not config.has_section("deepseek"):
> ui\views_deepseek.py:441:                config.add_section("deepseek")
  ui\views_deepseek.py:442:            
  ui\views_deepseek.py:443:            # NO loguear api_key
> ui\views_deepseek.py:444:            config.set("deepseek", "api_key", self.api_key_var.get())
> ui\views_deepseek.py:445:            config.set("deepseek", "base_url", self.base_url_var.get())
> ui\views_deepseek.py:446:            config.set("deepseek", "model", self.model_var.get())
> ui\views_deepseek.py:447:            config.set("deepseek", "temperature", self.temperature_var.get())
> ui\views_deepseek.py:448:            config.set("deepseek", "max_tokens", self.max_tokens_var.get())
  ui\views_deepseek.py:449:            
  ui\views_deepseek.py:450:            # Guardar
  ui\views_deepseek.py:451:            with open(CONFIG_FILE, "w", encoding="utf-8") as f:
  ui\views_deepseek.py:452:                config.write(f)
  ui\views_deepseek.py:453:            
> ui\views_deepseek.py:454:            messagebox.showinfo("OK", f"Configuración DeepSeek guardada en:\n{CONFIG_FILE}")
> ui\views_deepseek.py:455:            logger.info("Config DeepSeek guardada (api_key no logueada)")
  ui\views_deepseek.py:456:        except Exception as e:
> ui\views_deepseek.py:457:            logger.error(f"Error guardando config DeepSeek: {e}")
  ui\views_deepseek.py:458:            messagebox.showerror("Error", f"Error guardando configuración:\n{e}")
  ui\views_deepseek.py:459:    
> ui\views_deepseek.py:460:    def _probar_deepseek(self):
> ui\views_deepseek.py:461:        """Valida configuración DeepSeek (sin hacer llamadas reales)"""
  ui\views_deepseek.py:462:        errores = []
  ui\views_deepseek.py:463:        
  ui\views_deepseek.py:464:        if not self.api_key_var.get().strip():
  ui\views_deepseek.py:465:            errores.append("• API Key está vacía")
  ui\views_deepseek.py:466:        
  ui\views_deepseek.py:467:        if not self.base_url_var.get().strip():
  ui\views_deepseek.py:468:            errores.append("• Base URL está vacía")
  ui\views_deepseek.py:469:        
  ui\views_deepseek.py:470:        if not self.model_var.get().strip():
  ui\views_deepseek.py:471:            errores.append("• Model está vacío")
  ui\views_deepseek.py:472:        
  ui\views_deepseek.py:473:        try:
  ui\views_deepseek.py:474:            temp = float(self.temperature_var.get())
  ui\views_deepseek.py:475:            if temp < 0 or temp > 2:
  ui\views_deepseek.py:476:                errores.append("• Temperature debe estar entre 0 y 2")
  ui\views_deepseek.py:477:        except ValueError:
  ui\views_deepseek.py:478:            errores.append("• Temperature debe ser un número decimal")
  ui\views_deepseek.py:479:        
  ui\views_deepseek.py:480:        try:
  ui\views_deepseek.py:481:            max_tok = int(self.max_tokens_var.get())
  ui\views_deepseek.py:482:            if max_tok <= 0:
  ui\views_deepseek.py:483:                errores.append("• Max Tokens debe ser mayor a 0")
  ui\views_deepseek.py:484:        except ValueError:
  ui\views_deepseek.py:485:            errores.append("• Max Tokens debe ser un número entero")
  ui\views_deepseek.py:486:        
  ui\views_deepseek.py:487:        if errores:
  ui\views_deepseek.py:488:            messagebox.showerror(
  ui\views_deepseek.py:489:                "Validación Fallida",
  ui\views_deepseek.py:490:                "Se encontraron los siguientes errores:\n\n" + "\n".join(errores)
  ui\views_deepseek.py:491:            )
  ui\views_deepseek.py:492:        else:
  ui\views_deepseek.py:493:            messagebox.showinfo(
  ui\views_deepseek.py:494:                "Validación OK",
> ui\views_deepseek.py:495:                "✓ Configuración DeepSeek válida\n\n"
  ui\views_deepseek.py:496:                "Nota: No se realizaron llamadas reales a la API."
  ui\views_deepseek.py:497:            )
> ui\views_deepseek.py:498:            logger.info("Validación DeepSeek OK (api_key presente, base_url y model válidos)")
  ui\views_deepseek.py:499:    
  ui\views_deepseek.py:500:    def _toggle_api_key_visibility(self):
  ui\views_deepseek.py:501:        """Toggle visibilidad de API key"""
  ui\views_deepseek.py:502:        if self.show_api_key_var.get():
  ui\views_deepseek.py:503:            self.api_key_entry.config(show="")
  ui\views_deepseek.py:504:        else:
  ui\views_deepseek.py:505:            self.api_key_entry.config(show="*")
  ui\views_deepseek.py:506:    
  ui\views_deepseek.py:507:    # =================================================================
  ui\views_deepseek.py:508:    # MÉTODOS: Configuración DB
  ui\views_deepseek.py:509:    # =================================================================
  ui\views_deepseek.py:510:    
  ui\views_deepseek.py:511:    def _cargar_config_db_inicial(self):
  ui\views_deepseek.py:512:        """Carga config DB al iniciar"""
  ui\views_deepseek.py:513:        if not CONFIG_FILE.exists():
  ui\views_deepseek.py:514:            return
  ui\views_deepseek.py:515:        
  ui\views_deepseek.py:516:        try:
  ui\views_deepseek.py:517:            config = configparser.ConfigParser()
  ui\views_deepseek.py:518:            config.read(CONFIG_FILE, encoding="utf-8")
  ui\views_deepseek.py:519:            
  ui\views_deepseek.py:520:            if config.has_section(self.db_section):
  ui\views_deepseek.py:521:                self.db_host_var.set(config.get(self.db_section, "host", fallback=""))
  ui\views_deepseek.py:522:                self.db_port_var.set(config.get(self.db_section, "port", fallback="3306"))
  ui\views_deepseek.py:523:                self.db_user_var.set(config.get(self.db_section, "user", fallback=""))
  ui\views_deepseek.py:524:                self.db_password_var.set(config.get(self.db_section, "password", fallback=""))
  ui\views_deepseek.py:525:                
  ui\views_deepseek.py:526:                # Database puede ser 'database' o 'db'
  ui\views_deepseek.py:527:                db_name = config.get(self.db_section, "database", fallback="")
  ui\views_deepseek.py:528:                if not db_name:
  ui\views_deepseek.py:529:                    db_name = config.get(self.db_section, "db", fallback="")
  ui\views_deepseek.py:530:                self.db_database_var.set(db_name)
  ui\views_deepseek.py:531:                
  ui\views_deepseek.py:532:                logger.info(f"Config DB cargada desde sección [{self.db_section}]")
  ui\views_deepseek.py:533:        except Exception as e:
  ui\views_deepseek.py:534:            logger.warning(f"No se pudo cargar config DB inicial: {e}")
  ui\views_deepseek.py:535:    
  ui\views_deepseek.py:536:    def _cargar_config_db(self):
  ui\views_deepseek.py:537:        """Carga config DB desde config.ini"""
  ui\views_deepseek.py:538:        if not CONFIG_FILE.exists():
  ui\views_deepseek.py:539:            messagebox.showwarning(
  ui\views_deepseek.py:540:                "Archivo no encontrado",
  ui\views_deepseek.py:541:                f"El archivo {CONFIG_FILE} no existe.\n\n"
  ui\views_deepseek.py:542:                "Será creado al guardar la configuración."
  ui\views_deepseek.py:543:            )
  ui\views_deepseek.py:544:            return
  ui\views_deepseek.py:545:        
  ui\views_deepseek.py:546:        try:
  ui\views_deepseek.py:547:            config = configparser.ConfigParser()
  ui\views_deepseek.py:548:            config.read(CONFIG_FILE, encoding="utf-8")
  ui\views_deepseek.py:549:            
  ui\views_deepseek.py:550:            if not config.has_section(self.db_section):
  ui\views_deepseek.py:551:                messagebox.showwarning(
  ui\views_deepseek.py:552:                    "Sección no encontrada",
  ui\views_deepseek.py:553:                    f"No se encontró la sección [{self.db_section}] en config.ini.\n\n"
  ui\views_deepseek.py:554:                    "Será creada al guardar."
  ui\views_deepseek.py:555:                )
  ui\views_deepseek.py:556:                return
  ui\views_deepseek.py:557:            
  ui\views_deepseek.py:558:            self.db_host_var.set(config.get(self.db_section, "host", fallback=""))
  ui\views_deepseek.py:559:            self.db_port_var.set(config.get(self.db_section, "port", fallback="3306"))
  ui\views_deepseek.py:560:            self.db_user_var.set(config.get(self.db_section, "user", fallback=""))
  ui\views_deepseek.py:561:            self.db_password_var.set(config.get(self.db_section, "password", fallback=""))
  ui\views_deepseek.py:562:            
  ui\views_deepseek.py:563:            # Database puede ser 'database' o 'db'
  ui\views_deepseek.py:564:            db_name = config.get(self.db_section, "database", fallback="")
  ui\views_deepseek.py:565:            if not db_name:
  ui\views_deepseek.py:566:                db_name = config.get(self.db_section, "db", fallback="")
  ui\views_deepseek.py:567:            self.db_database_var.set(db_name)
  ui\views_deepseek.py:568:            
  ui\views_deepseek.py:569:            messagebox.showinfo("OK", f"Configuración DB cargada desde sección [{self.db_section}]")
  ui\views_deepseek.py:570:            logger.info(f"Config DB cargada desde [{self.db_section}]")
  ui\views_deepseek.py:571:        except Exception as e:
  ui\views_deepseek.py:572:            logger.error(f"Error cargando config DB: {e}")
  ui\views_deepseek.py:573:            messagebox.showerror("Error", f"Error cargando configuración DB:\n{e}")
  ui\views_deepseek.py:574:    
  ui\views_deepseek.py:575:    def _guardar_config_db(self):
  ui\views_deepseek.py:576:        """Guarda config DB a config.ini"""
  ui\views_deepseek.py:577:        try:
  ui\views_deepseek.py:578:            # Leer config existente (preservar otras secciones)
  ui\views_deepseek.py:579:            config = configparser.ConfigParser()
  ui\views_deepseek.py:580:            if CONFIG_FILE.exists():
  ui\views_deepseek.py:581:                config.read(CONFIG_FILE, encoding="utf-8")
  ui\views_deepseek.py:582:            
  ui\views_deepseek.py:583:            # Crear/actualizar sección DB
  ui\views_deepseek.py:584:            if not config.has_section(self.db_section):
  ui\views_deepseek.py:585:                config.add_section(self.db_section)
  ui\views_deepseek.py:586:            
  ui\views_deepseek.py:587:            # NO loguear password
  ui\views_deepseek.py:588:            config.set(self.db_section, "host", self.db_host_var.get())
  ui\views_deepseek.py:589:            config.set(self.db_section, "port", self.db_port_var.get())
  ui\views_deepseek.py:590:            config.set(self.db_section, "user", self.db_user_var.get())
  ui\views_deepseek.py:591:            config.set(self.db_section, "password", self.db_password_var.get())
  ui\views_deepseek.py:592:            config.set(self.db_section, "database", self.db_database_var.get())
  ui\views_deepseek.py:593:            
  ui\views_deepseek.py:594:            # Guardar
  ui\views_deepseek.py:595:            with open(CONFIG_FILE, "w", encoding="utf-8") as f:
  ui\views_deepseek.py:596:                config.write(f)
  ui\views_deepseek.py:597:            
  ui\views_deepseek.py:598:            messagebox.showinfo(
  ui\views_deepseek.py:599:                "OK",
  ui\views_deepseek.py:600:                f"Configuración DB guardada en:\n{CONFIG_FILE}\n\n"
  ui\views_deepseek.py:601:                f"Sección: [{self.db_section}]\n\n"
  ui\views_deepseek.py:602:                "Reinicie la aplicación para aplicar los cambios."
  ui\views_deepseek.py:603:            )
  ui\views_deepseek.py:604:            logger.info(f"Config DB guardada en sección [{self.db_section}] (password no logueada)")
  ui\views_deepseek.py:605:        except Exception as e:
  ui\views_deepseek.py:606:            logger.error(f"Error guardando config DB: {e}")
  ui\views_deepseek.py:607:            messagebox.showerror("Error", f"Error guardando configuración DB:\n{e}")
  ui\views_deepseek.py:608:    
  ui\views_deepseek.py:609:    def _probar_conexion_db(self):
  ui\views_deepseek.py:610:        """Prueba la conexión a la base de datos"""
  ui\views_deepseek.py:611:        try:
  ui\views_deepseek.py:612:            import mysql.connector
  ui\views_deepseek.py:613:            
  ui\views_deepseek.py:614:            # Intentar conectar con los valores ingresados
  ui\views_deepseek.py:615:            conn = mysql.connector.connect(
  ui\views_deepseek.py:616:                host=self.db_host_var.get(),
  ui\views_deepseek.py:617:                port=int(self.db_port_var.get()),
  ui\views_deepseek.py:618:                user=self.db_user_var.get(),
> ui\views_detalles.py:230:        info += f"Fase: {turno.fase or '(none)'} | Source: {turno.fase_source or '(none)'} | Conf: {turno.fase_conf or 'N/A'}\n"
  ui\views_detalles.py:231:        if turno.intent:
  ui\views_detalles.py:232:            info += f"Intent: {turno.intent} | Intent Conf: {turno.intent_conf or 'N/A'}\n"
  ui\views_detalles.py:233:        info += f"\n{text}"
  ui\views_detalles.py:234:        
  ui\views_detalles.py:235:        self.detalle_text.insert("1.0", info)
  ui\views_detalles.py:236:    
  ui\views_detalles.py:237:    def _schedule_queue_check(self):
  ui\views_detalles.py:238:        """Revisa cola de tareas"""
  ui\views_detalles.py:239:        try:
  ui\views_detalles.py:240:            while True:
  ui\views_detalles.py:241:                msg = self.task_queue.get_nowait()
  ui\views_detalles.py:242:                self._process_queue_message(msg)
  ui\views_detalles.py:243:        except queue.Empty:
  ui\views_detalles.py:244:            pass
  ui\views_detalles.py:245:        finally:
  ui\views_detalles.py:246:            self.after(100, self._schedule_queue_check)
  ui\views_detalles.py:247:    
  ui\views_detalles.py:248:    def _process_queue_message(self, msg):
  ui\views_detalles.py:249:        """Procesa mensajes de la cola"""
  ui\views_detalles.py:250:        if msg[0] == "ejecuciones_cargadas":
  ui\views_detalles.py:251:            self.ejecuciones = msg[1]
  ui\views_detalles.py:252:            self._update_ejecuciones_combo()
  ui\views_detalles.py:253:        elif msg[0] == "conversaciones_cargadas":
  ui\views_detalles.py:254:            self.conversaciones = msg[1]
  ui\views_detalles.py:255:            self._update_conversaciones_tree()
  ui\views_detalles.py:256:        elif msg[0] == "turnos_cargados":
  ui\views_detalles.py:257:            self.turnos = msg[1]
  ui\views_detalles.py:258:            self._update_turnos_tree()
  ui\views_detalles.py:259:        elif msg[0] == "error":
  ui\views_detalles.py:260:            messagebox.showerror("Error", msg[1])
  ui\views_detalles.py:261:    
  ui\views_detalles.py:262:    def _update_ejecuciones_combo(self):
  ui\views_detalles.py:263:        """Actualiza combo de ejecuciones"""
  ui\views_detalles.py:264:        values = [f"Ejecución {ej.ejecucion_id} ({ej.num_conversaciones} convs)" 
  ui\views_detalles.py:265:                 for ej in self.ejecuciones]
  ui\views_detalles.py:266:        self.ejecucion_combo["values"] = values
  ui\views_detalles.py:267:        if values:
  ui\views_detalles.py:268:            self.ejecucion_combo.current(0)
  ui\views_detalles.py:269:            self.ejecucion_actual = self.ejecuciones[0].ejecucion_id
  ui\views_detalles.py:270:    
  ui\views_detalles.py:271:    def _update_conversaciones_tree(self):
  ui\views_detalles.py:272:        """Actualiza tree de conversaciones"""
  ui\views_detalles.py:273:        # Limpiar
  ui\views_detalles.py:274:        for item in self.conversaciones_tree.get_children():
  ui\views_detalles.py:275:            self.conversaciones_tree.delete(item)
  ui\views_detalles.py:276:        
  ui\views_detalles.py:277:        # Llenar
  ui\views_detalles.py:278:        for conv in self.conversaciones:
  ui\views_detalles.py:279:            self.conversaciones_tree.insert(
  ui\views_detalles.py:280:                "", tk.END,
  ui\views_detalles.py:281:                values=(conv.conversacion_pk, conv.conversacion_id or "(sin ID)")
  ui\views_detalles.py:282:            )
  ui\views_detalles.py:283:    
  ui\views_detalles.py:284:    def _update_turnos_tree(self):
  ui\views_detalles.py:285:        """Actualiza tree de turnos"""
  ui\views_detalles.py:286:        # Limpiar
  ui\views_detalles.py:287:        for item in self.turnos_tree.get_children():
  ui\views_detalles.py:288:            self.turnos_tree.delete(item)
  ui\views_detalles.py:289:        
  ui\views_detalles.py:290:        # Limpiar detalle
  ui\views_detalles.py:291:        self.detalle_text.delete("1.0", tk.END)
  ui\views_detalles.py:292:        
  ui\views_detalles.py:293:        # Llenar
  ui\views_detalles.py:294:        for turno in self.turnos:
> ui\views_detalles.py:295:            conf_str = f"{turno.fase_conf:.2f}" if turno.fase_conf is not None else "N/A"
  ui\views_detalles.py:296:            self.turnos_tree.insert(
  ui\views_detalles.py:297:                "", tk.END,
  ui\views_detalles.py:298:                values=(
  ui\views_detalles.py:299:                    turno.turno_idx,
  ui\views_detalles.py:300:                    turno.speaker or "?",
  ui\views_detalles.py:301:                    turno.fase or "(none)",
  ui\views_detalles.py:302:                    turno.fase_source or "(none)",
  ui\views_detalles.py:303:                    conf_str
  ui\views_detalles.py:304:                )
  ui\views_detalles.py:305:            )
> scripts\export_pendientes_llm.py:13:    - Pendientes: (t.fase IS NULL OR TRIM(t.fase)='' OR IFNULL(t.fase_conf,0) < conf_threshold)
> scripts\export_pendientes_llm.py:14:    - Excluye los con t.fase_source='DEEPSEEK'
  scripts\export_pendientes_llm.py:15:    - Incluye prev_fase y next_fase via self-joins
> scripts\export_pendientes_llm.py:16:    CSV columnas EXACTAS: turno_pk, conv_pk, turno_idx, conversacion_id, text, fase, fase_conf, fase_source, prev_fase, next_fase
  scripts\export_pendientes_llm.py:17:    Retorna dict con path y rows
  scripts\export_pendientes_llm.py:18:    """
  scripts\export_pendientes_llm.py:19:    os.makedirs(out_dir, exist_ok=True)
  scripts\export_pendientes_llm.py:20:    out_path = os.path.join(out_dir, f"run_{ejecucion_id}_pendientes_llm.csv")
  scripts\export_pendientes_llm.py:21:
  scripts\export_pendientes_llm.py:22:    cur = conn.cursor()
  scripts\export_pendientes_llm.py:23:    sql = (
  scripts\export_pendientes_llm.py:24:        """
  scripts\export_pendientes_llm.py:25:        SELECT
  scripts\export_pendientes_llm.py:26:          t.turno_pk,
  scripts\export_pendientes_llm.py:27:          t.conversacion_pk AS conv_pk,
  scripts\export_pendientes_llm.py:28:          t.turno_idx,
  scripts\export_pendientes_llm.py:29:          c.conversacion_id,
  scripts\export_pendientes_llm.py:30:          t.text,
> scripts\export_pendientes_llm.py:31:          t.fase,
> scripts\export_pendientes_llm.py:32:          t.fase_conf,
  scripts\export_pendientes_llm.py:33:          t.fase_source,
  scripts\export_pendientes_llm.py:34:          t_prev.fase AS prev_fase,
> scripts\export_pendientes_llm.py:35:          t_next.fase AS next_fase
  scripts\export_pendientes_llm.py:36:        FROM sa_turnos t
  scripts\export_pendientes_llm.py:37:        JOIN sa_conversaciones c ON c.conversacion_pk=t.conversacion_pk
  scripts\export_pendientes_llm.py:38:        LEFT JOIN sa_turnos t_prev ON t_prev.conversacion_pk=t.conversacion_pk AND t_prev.turno_idx=t.turno_idx-1
  scripts\export_pendientes_llm.py:39:        LEFT JOIN sa_turnos t_next ON t_next.conversacion_pk=t.conversacion_pk AND t_next.turno_idx=t.turno_idx+1
  scripts\export_pendientes_llm.py:40:                WHERE c.ejecucion_id=%s
  scripts\export_pendientes_llm.py:41:                    AND t.fase_source = 'NO_IMP'  -- Solo imputados desde NOISE, candidatos para LLM
  scripts\export_pendientes_llm.py:42:                    AND t.fase_source <> 'IMPUTE_SHORT'  -- Exclusión explícita para evitar regresiones
  scripts\export_pendientes_llm.py:43:        ORDER BY t.conversacion_pk, t.turno_idx
  scripts\export_pendientes_llm.py:44:        """
  scripts\export_pendientes_llm.py:45:    )
  scripts\export_pendientes_llm.py:46:
  scripts\export_pendientes_llm.py:47:    params = [ejecucion_id]
  scripts\export_pendientes_llm.py:48:    if limit and limit > 0:
  scripts\export_pendientes_llm.py:49:        sql += " LIMIT %s"
  scripts\export_pendientes_llm.py:50:        params.append(limit)
  scripts\export_pendientes_llm.py:51:
  scripts\export_pendientes_llm.py:52:    cur.execute(sql, tuple(params))
  scripts\export_pendientes_llm.py:53:    rows = cur.fetchall()
  scripts\export_pendientes_llm.py:54:    cur.close()
  scripts\export_pendientes_llm.py:55:
  scripts\export_pendientes_llm.py:56:    total_rows = 0
  scripts\export_pendientes_llm.py:57:    with open(out_path, "w", encoding="utf-8", newline="") as f:
  scripts\export_pendientes_llm.py:58:        wr = csv.writer(f)
  scripts\export_pendientes_llm.py:59:        wr.writerow([
  scripts\export_pendientes_llm.py:60:            "turno_pk",
  scripts\export_pendientes_llm.py:61:            "conv_pk",
  scripts\export_pendientes_llm.py:62:            "turno_idx",
  scripts\export_pendientes_llm.py:63:            "conversacion_id",
  scripts\export_pendientes_llm.py:64:            "text",
  scripts\export_pendientes_llm.py:65:            "fase",
> scripts\export_pendientes_llm.py:66:            "fase_conf",
  scripts\export_pendientes_llm.py:67:            "fase_source",
  scripts\export_pendientes_llm.py:68:            "prev_fase",
  scripts\export_pendientes_llm.py:69:            "next_fase",
  scripts\export_pendientes_llm.py:70:        ])
  scripts\export_pendientes_llm.py:71:        for r in rows:
  scripts\export_pendientes_llm.py:72:            wr.writerow([
  scripts\export_pendientes_llm.py:73:                int(r[0]),  # turno_pk
  scripts\export_pendientes_llm.py:74:                int(r[1]),  # conv_pk
  scripts\export_pendientes_llm.py:75:                int(r[2]),  # turno_idx
  scripts\export_pendientes_llm.py:76:                r[3],       # conversacion_id
  scripts\export_pendientes_llm.py:77:                r[4] or "",
  scripts\export_pendientes_llm.py:78:                (r[5] or ""),
  scripts\export_pendientes_llm.py:79:                r[6] if r[6] is not None else "",
  scripts\export_pendientes_llm.py:80:                (r[7] or ""),
  scripts\export_pendientes_llm.py:81:                (r[8] or ""),
  scripts\export_pendientes_llm.py:82:                (r[9] or ""),
  scripts\export_pendientes_llm.py:83:            ])
  scripts\export_pendientes_llm.py:84:            total_rows += 1
  scripts\export_pendientes_llm.py:85:
  scripts\export_pendientes_llm.py:86:    print(f"[OK] wrote: {out_path} rows={total_rows} ejecucion_id={ejecucion_id} conf_threshold={conf_threshold}")
  scripts\export_pendientes_llm.py:87:    return {"path": out_path, "rows": total_rows}
  scripts\export_pendientes_llm.py:88:
  scripts\export_pendientes_llm.py:89:
  scripts\export_pendientes_llm.py:90:def main():
  scripts\export_pendientes_llm.py:91:    ap = argparse.ArgumentParser(description="Exporta pendientes LLM a CSV")
  scripts\export_pendientes_llm.py:92:    ap.add_argument("--ejecucion_id", type=int, required=True)
  scripts\export_pendientes_llm.py:93:    ap.add_argument("--conf_threshold", type=float, default=0.55)
  scripts\export_pendientes_llm.py:94:    ap.add_argument("--limit", type=int, default=0)
  scripts\export_pendientes_llm.py:95:    ap.add_argument("--out_dir", default="out_reports")
  scripts\export_pendientes_llm.py:96:    ap.add_argument("--config", default="config.ini")
  scripts\export_pendientes_llm.py:97:    args = ap.parse_args()
  scripts\export_pendientes_llm.py:98:
  scripts\export_pendientes_llm.py:99:    cfg = load_config(args.config)
  scripts\export_pendientes_llm.py:100:    conn = get_conn(cfg)
  scripts\export_pendientes_llm.py:101:    try:
  scripts\export_pendientes_llm.py:102:        export_pendientes_llm(conn, args.ejecucion_id, args.conf_threshold, args.limit, args.out_dir)
  scripts\export_pendientes_llm.py:103:    finally:
  scripts\export_pendientes_llm.py:104:        if conn and conn.is_connected():
  scripts\export_pendientes_llm.py:105:            conn.close()
  scripts\export_pendientes_llm.py:106:
  scripts\export_pendientes_llm.py:107:
  scripts\export_pendientes_llm.py:108:if __name__ == "__main__":
  scripts\export_pendientes_llm.py:109:    main()
> scripts\extract_promesas_pago.py:611:    SELECT c.conversacion_pk, c.conversacion_id, t.turno_pk, t.turno_idx, t.speaker, t.text, t.fase, t.fase_source
  scripts\extract_promesas_pago.py:612:    FROM sa_conversaciones c
  scripts\extract_promesas_pago.py:613:    JOIN sa_turnos t ON t.conversacion_pk = c.conversacion_pk
  scripts\extract_promesas_pago.py:614:    WHERE c.ejecucion_id = %s
  scripts\extract_promesas_pago.py:615:    ORDER BY c.conversacion_pk, t.turno_idx
  scripts\extract_promesas_pago.py:616:    """
  scripts\extract_promesas_pago.py:617:    params = [args.ejecucion_id]
  scripts\extract_promesas_pago.py:618:    if args.limit_convs > 0:
  scripts\extract_promesas_pago.py:619:        # limitar conversacion_pk con subquery
  scripts\extract_promesas_pago.py:620:        q = """
> scripts\extract_promesas_pago.py:621:        SELECT c.conversacion_pk, c.conversacion_id, t.turno_pk, t.turno_idx, t.speaker, t.text, t.fase, t.fase_source
  scripts\extract_promesas_pago.py:622:        FROM (
  scripts\extract_promesas_pago.py:623:            SELECT conversacion_pk, conversacion_id
  scripts\extract_promesas_pago.py:624:            FROM sa_conversaciones
  scripts\extract_promesas_pago.py:625:            WHERE ejecucion_id=%s
  scripts\extract_promesas_pago.py:626:            ORDER BY conversacion_pk
  scripts\extract_promesas_pago.py:627:            LIMIT %s
  scripts\extract_promesas_pago.py:628:        ) c
  scripts\extract_promesas_pago.py:629:        JOIN sa_turnos t ON t.conversacion_pk = c.conversacion_pk
  scripts\extract_promesas_pago.py:630:        ORDER BY c.conversacion_pk, t.turno_idx
  scripts\extract_promesas_pago.py:631:        """
  scripts\extract_promesas_pago.py:632:        params = [args.ejecucion_id, args.limit_convs]
  scripts\extract_promesas_pago.py:633:
  scripts\extract_promesas_pago.py:634:    cur.execute(q, tuple(params))
  scripts\extract_promesas_pago.py:635:
  scripts\extract_promesas_pago.py:636:    # agrupar por conversación, recolectar candidatos
  scripts\extract_promesas_pago.py:637:    promesas = []
  scripts\extract_promesas_pago.py:638:    last_conv = None
  scripts\extract_promesas_pago.py:639:    turns_buf = []
  scripts\extract_promesas_pago.py:640:
  scripts\extract_promesas_pago.py:641:    def flush_conv(conv_pk, conv_id, turns):
  scripts\extract_promesas_pago.py:642:        if not turns:
  scripts\extract_promesas_pago.py:643:            return
  scripts\extract_promesas_pago.py:644:        # buscar en fases clave primero
  scripts\extract_promesas_pago.py:645:        candidates = []
  scripts\extract_promesas_pago.py:646:        for row in turns:
  scripts\extract_promesas_pago.py:647:            txt = row["text"] or ""
  scripts\extract_promesas_pago.py:648:            if not txt.strip():
  scripts\extract_promesas_pago.py:649:                continue
  scripts\extract_promesas_pago.py:650:            if row.get("fase") in ("OFERTA_PAGO", "FORMALIZACION_PAGO", "NEGOCIACION_ACUERDO", "CONSULTA_ACEPTACION"):
  scripts\extract_promesas_pago.py:651:                candidates.append(row)
  scripts\extract_promesas_pago.py:652:            elif is_promesa_text(txt):
  scripts\extract_promesas_pago.py:653:                candidates.append(row)
  scripts\extract_promesas_pago.py:654:
  scripts\extract_promesas_pago.py:655:        if not candidates:
  scripts\extract_promesas_pago.py:656:            return
  scripts\extract_promesas_pago.py:657:
  scripts\extract_promesas_pago.py:658:        # elegir el mejor candidato con scoring
  scripts\extract_promesas_pago.py:659:        best = None
  scripts\extract_promesas_pago.py:660:        best_score = -1
  scripts\extract_promesas_pago.py:661:
  scripts\extract_promesas_pago.py:662:        for row in candidates:
  scripts\extract_promesas_pago.py:663:            txt = row["text"] or ""
  scripts\extract_promesas_pago.py:664:            monto, moneda = parse_money(txt)
  scripts\extract_promesas_pago.py:665:            
  scripts\extract_promesas_pago.py:666:            # Intentar extracción alternativa si parse_money no encontró nada
  scripts\extract_promesas_pago.py:667:            if monto is None:
  scripts\extract_promesas_pago.py:668:                monto, moneda = parse_amount_and_currency(txt)
  scripts\extract_promesas_pago.py:669:            
  scripts\extract_promesas_pago.py:670:            cuotas = parse_cuotas(txt)
  scripts\extract_promesas_pago.py:671:            fecha, fecha_txt = parse_fecha(txt, base_date)
  scripts\extract_promesas_pago.py:672:            st = estado_from_fields(monto, fecha, cuotas, txt)
  scripts\extract_promesas_pago.py:673:            if not st:
  scripts\extract_promesas_pago.py:674:                continue
  scripts\extract_promesas_pago.py:675:
  scripts\extract_promesas_pago.py:676:            score = 0
  scripts\extract_promesas_pago.py:677:            if monto: score += 5
  scripts\extract_promesas_pago.py:678:            if fecha: score += 4
  scripts\extract_promesas_pago.py:679:            if cuotas: score += 2
  scripts\extract_promesas_pago.py:680:            if row.get("fase") == "FORMALIZACION_PAGO": score += 2
  scripts\extract_promesas_pago.py:681:            if row.get("fase") == "NEGOCIACION_ACUERDO": score += 2
  scripts\extract_promesas_pago.py:682:            if "promesa" in (txt.lower()): score += 2
  scripts\extract_promesas_pago.py:683:            if "comprom" in (txt.lower()): score += 1
  scripts\extract_promesas_pago.py:684:
  scripts\extract_promesas_pago.py:685:            if score > best_score:
  scripts\extract_promesas_pago.py:686:                best_score = score
  scripts\extract_promesas_pago.py:687:                best = (row, monto, moneda, cuotas, fecha, fecha_txt, st, score)
  scripts\extract_promesas_pago.py:688:
  scripts\extract_promesas_pago.py:689:        if not best:
  scripts\extract_promesas_pago.py:690:            return
  scripts\extract_promesas_pago.py:691:
  scripts\extract_promesas_pago.py:692:        row, monto, moneda, cuotas, fecha, fecha_txt, st, score = best
  scripts\extract_promesas_pago.py:693:
  scripts\extract_promesas_pago.py:694:        # Si no hay monto (PENDIENTE_MONTO*), buscar en contexto de turnos vecinos
  scripts\extract_promesas_pago.py:695:        if monto is None and st in ("PENDIENTE_MONTO", "PENDIENTE_MONTO_CON_FECHA"):
  scripts\extract_promesas_pago.py:696:            turno_idx_actual = row["turno_idx"]
  scripts\extract_promesas_pago.py:697:            
  scripts\extract_promesas_pago.py:698:            # Construir índice de turnos por turno_idx para acceso rápido
  scripts\extract_promesas_pago.py:699:            turns_by_idx = {t["turno_idx"]: t for t in turns}
  scripts\extract_promesas_pago.py:700:            
  scripts\extract_promesas_pago.py:701:            # Recolectar hasta 2 turnos anteriores y 2 posteriores
  scripts\extract_promesas_pago.py:702:            context_parts = []
  scripts\extract_promesas_pago.py:703:            for offset in [-2, -1, 0, 1, 2]:
  scripts\extract_promesas_pago.py:704:                idx = turno_idx_actual + offset
  scripts\extract_promesas_pago.py:705:                if idx in turns_by_idx:
  scripts\extract_promesas_pago.py:706:                    t = turns_by_idx[idx]
  scripts\extract_promesas_pago.py:707:                    txt_part = (t.get("text") or "").strip()
  scripts\extract_promesas_pago.py:708:                    if txt_part:
  scripts\extract_promesas_pago.py:709:                        # Etiquetar con posición relativa
  scripts\extract_promesas_pago.py:710:                        label = f"[t{offset:+d}]" if offset != 0 else "[t0]"
  scripts\extract_promesas_pago.py:711:                        context_parts.append(f"{label} {txt_part}")
  scripts\extract_promesas_pago.py:712:            
  scripts\extract_promesas_pago.py:713:            # Concatenar contexto
  scripts\extract_promesas_pago.py:714:            context_text = " ".join(context_parts)
  scripts\extract_promesas_pago.py:715:            
  scripts\extract_promesas_pago.py:716:            # Intentar extraer monto del contexto
  scripts\extract_promesas_pago.py:717:            context_monto, context_moneda = parse_amount_and_currency(context_text)
  scripts\extract_promesas_pago.py:718:            
  scripts\extract_promesas_pago.py:719:            # Si encontramos monto en contexto, actualizar
  scripts\extract_promesas_pago.py:720:            if context_monto is not None:
  scripts\extract_promesas_pago.py:721:                monto = context_monto
  scripts\extract_promesas_pago.py:722:                # Preservar moneda si ya existía (por palabras clave globales)
  scripts\extract_promesas_pago.py:723:                if moneda is None:
  scripts\extract_promesas_pago.py:724:                    moneda = context_moneda
  scripts\extract_promesas_pago.py:725:                
  scripts\extract_promesas_pago.py:726:                # Actualizar estado según nuevos campos
  scripts\extract_promesas_pago.py:727:                st = estado_from_fields(monto, fecha, cuotas, row["text"])
  scripts\extract_promesas_pago.py:728:        
  scripts\extract_promesas_pago.py:729:        # Si hay monto pero no moneda, intentar inferir moneda del contexto de turnos
  scripts\extract_promesas_pago.py:730:        if monto is not None and moneda is None:
  scripts\extract_promesas_pago.py:731:            turno_idx_actual = row["turno_idx"]
  scripts\extract_promesas_pago.py:732:            
  scripts\extract_promesas_pago.py:733:            # Construir índice de turnos si no existe (puede ya existir del bloque anterior)
  scripts\extract_promesas_pago.py:734:            if 'turns_by_idx' not in locals():
  scripts\extract_promesas_pago.py:735:                turns_by_idx = {t["turno_idx"]: t for t in turns}
  scripts\extract_promesas_pago.py:736:            
  scripts\extract_promesas_pago.py:737:            # Recolectar contexto si no existe (puede ya existir del bloque anterior)
  scripts\extract_promesas_pago.py:738:            if 'context_text' not in locals():
  scripts\extract_promesas_pago.py:739:                context_parts = []
  scripts\extract_promesas_pago.py:740:                for offset in [-2, -1, 0, 1, 2]:
  scripts\extract_promesas_pago.py:741:                    idx = turno_idx_actual + offset
> scripts\postprocess_ejecucion.py:48:    SET t.fase = t_prev.fase, t.fase_source = %s
  scripts\postprocess_ejecucion.py:49:    WHERE c.ejecucion_id = %s
> scripts\postprocess_ejecucion.py:50:      AND t.fase_source = 'NOISE' AND (t.fase IS NULL OR TRIM(t.fase) = '')
  scripts\postprocess_ejecucion.py:51:      AND t_prev.fase IS NOT NULL AND TRIM(t_prev.fase) <> ''
  scripts\postprocess_ejecucion.py:52:    """
  scripts\postprocess_ejecucion.py:53:    params = (NOISE_IMPUTE_SOURCE, ejecucion_id)
  scripts\postprocess_ejecucion.py:54:    cur.execute(sql_prev, params)
  scripts\postprocess_ejecucion.py:55:    count_prev = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:56:    print(f"  - Imputed from previous turn: {count_prev} rows")
  scripts\postprocess_ejecucion.py:57:
  scripts\postprocess_ejecucion.py:58:    # Imputar desde el turno siguiente
  scripts\postprocess_ejecucion.py:59:    sql_next = """
  scripts\postprocess_ejecucion.py:60:    UPDATE sa_turnos t
  scripts\postprocess_ejecucion.py:61:    JOIN sa_turnos t_next ON t.conversacion_pk = t_next.conversacion_pk AND t.turno_idx = t_next.turno_idx - 1
  scripts\postprocess_ejecucion.py:62:    JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
> scripts\postprocess_ejecucion.py:63:    SET t.fase = t_next.fase, t.fase_source = %s
  scripts\postprocess_ejecucion.py:64:    WHERE c.ejecucion_id = %s
> scripts\postprocess_ejecucion.py:65:      AND t.fase_source = 'NOISE' AND (t.fase IS NULL OR TRIM(t.fase) = '')
> scripts\postprocess_ejecucion.py:66:      AND t_next.fase IS NOT NULL AND TRIM(t_next.fase) <> ''
  scripts\postprocess_ejecucion.py:67:    """
  scripts\postprocess_ejecucion.py:68:    params = (NOISE_IMPUTE_SOURCE, ejecucion_id)
  scripts\postprocess_ejecucion.py:69:    cur.execute(sql_next, params)
  scripts\postprocess_ejecucion.py:70:    count_next = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:71:    print(f"  - Imputed from next turn: {count_next} rows")
  scripts\postprocess_ejecucion.py:72:    return count_prev + count_next
  scripts\postprocess_ejecucion.py:73:
  scripts\postprocess_ejecucion.py:74:def apertura_midcall_impute_prev(cur, ejecucion_id, do_write, verbose):
  scripts\postprocess_ejecucion.py:75:    """Corrige 'APERTURA' en mitad de llamada copiando la fase previa."""
  scripts\postprocess_ejecucion.py:76:    print("\n2) Correcting mid-call APERTURA from previous turn...")
  scripts\postprocess_ejecucion.py:77:    sql = """
  scripts\postprocess_ejecucion.py:78:    UPDATE sa_turnos t
  scripts\postprocess_ejecucion.py:79:    JOIN sa_turnos t_prev ON t.conversacion_pk = t_prev.conversacion_pk AND t.turno_idx = t_prev.turno_idx + 1
  scripts\postprocess_ejecucion.py:80:    JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
> scripts\postprocess_ejecucion.py:81:    SET t.fase = t_prev.fase, t.fase_source = %s
  scripts\postprocess_ejecucion.py:82:    WHERE c.ejecucion_id = %s
> scripts\postprocess_ejecucion.py:83:      AND t.fase = 'APERTURA' AND t.turno_idx > 2
  scripts\postprocess_ejecucion.py:84:      AND t_prev.fase IS NOT NULL AND TRIM(t_prev.fase) <> '' AND t_prev.fase <> 'APERTURA'
  scripts\postprocess_ejecucion.py:85:    """
  scripts\postprocess_ejecucion.py:86:    params = (APERTURA_IMPUTE_SOURCE, ejecucion_id)
  scripts\postprocess_ejecucion.py:87:    cur.execute(sql, params)
  scripts\postprocess_ejecucion.py:88:    count = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:89:    print(f"  - Corrected mid-call APERTURA: {count} rows")
  scripts\postprocess_ejecucion.py:90:    return count
  scripts\postprocess_ejecucion.py:91:
  scripts\postprocess_ejecucion.py:92:def apertura_midcall_backfill_when_has_next(cur, ejecucion_id, do_write, verbose):
  scripts\postprocess_ejecucion.py:93:    """Busca hacia atrás una fase válida para 'APERTURA' en mitad de llamada."""
  scripts\postprocess_ejecucion.py:94:    print("\n3) Backfilling mid-call APERTURA from nearest valid past turn...")
  scripts\postprocess_ejecucion.py:95:    sql = """
  scripts\postprocess_ejecucion.py:96:    UPDATE sa_turnos t
  scripts\postprocess_ejecucion.py:97:    JOIN sa_turnos t_next ON t.conversacion_pk = t_next.conversacion_pk AND t.turno_idx = t_next.turno_idx - 1
  scripts\postprocess_ejecucion.py:98:    JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
  scripts\postprocess_ejecucion.py:99:    JOIN (
  scripts\postprocess_ejecucion.py:100:        SELECT t_sub.turno_pk, 
> scripts\postprocess_ejecucion.py:101:               (SELECT t_past.fase 
  scripts\postprocess_ejecucion.py:102:                FROM sa_turnos t_past
  scripts\postprocess_ejecucion.py:103:                WHERE t_past.conversacion_pk = t_sub.conversacion_pk AND t_past.turno_idx < t_sub.turno_idx
> scripts\postprocess_ejecucion.py:104:                  AND t_past.fase IS NOT NULL AND TRIM(t_past.fase) <> '' AND t_past.fase <> 'APERTURA'
  scripts\postprocess_ejecucion.py:105:                ORDER BY t_past.turno_idx DESC 
  scripts\postprocess_ejecucion.py:106:                LIMIT 1) as prev_fase
  scripts\postprocess_ejecucion.py:107:        FROM sa_turnos t_sub
  scripts\postprocess_ejecucion.py:108:    ) as prev_data ON t.turno_pk = prev_data.turno_pk
> scripts\postprocess_ejecucion.py:109:    SET t.fase = prev_data.prev_fase, t.fase_source = %s
  scripts\postprocess_ejecucion.py:110:    WHERE c.ejecucion_id = %s
> scripts\postprocess_ejecucion.py:111:      AND t.fase = 'APERTURA'
  scripts\postprocess_ejecucion.py:112:      AND prev_data.prev_fase IS NOT NULL
  scripts\postprocess_ejecucion.py:113:    """
  scripts\postprocess_ejecucion.py:114:    params = (APERTURA_BACKFILL_SOURCE, ejecucion_id)
  scripts\postprocess_ejecucion.py:115:    cur.execute(sql, params)
  scripts\postprocess_ejecucion.py:116:    count = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:117:    print(f"  - Backfilled mid-call APERTURA: {count} rows")
  scripts\postprocess_ejecucion.py:118:    return count
  scripts\postprocess_ejecucion.py:119:
  scripts\postprocess_ejecucion.py:120:def cierre_midcall_impute_prev_when_has_next(cur, ejecucion_id, do_write, verbose):
  scripts\postprocess_ejecucion.py:121:    """Corrige 'CIERRE' en mitad de llamada si tiene turno siguiente."""
  scripts\postprocess_ejecucion.py:122:    print("\n4) Correcting mid-call CIERRE from previous turn...")
  scripts\postprocess_ejecucion.py:123:    sql = """
  scripts\postprocess_ejecucion.py:124:    UPDATE sa_turnos t
  scripts\postprocess_ejecucion.py:125:    JOIN sa_turnos t_prev ON t.conversacion_pk = t_prev.conversacion_pk AND t.turno_idx = t_prev.turno_idx + 1
  scripts\postprocess_ejecucion.py:126:    JOIN sa_turnos t_next ON t.conversacion_pk = t_next.conversacion_pk AND t.turno_idx = t_next.turno_idx - 1
  scripts\postprocess_ejecucion.py:127:    JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
> scripts\postprocess_ejecucion.py:128:    SET t.fase = t_prev.fase, t.fase_source = %s
  scripts\postprocess_ejecucion.py:129:    WHERE c.ejecucion_id = %s
> scripts\postprocess_ejecucion.py:130:      AND t.fase = 'CIERRE'
  scripts\postprocess_ejecucion.py:131:      AND t_prev.fase IS NOT NULL AND TRIM(t_prev.fase) <> '' AND t_prev.fase <> 'CIERRE'
  scripts\postprocess_ejecucion.py:132:    """
  scripts\postprocess_ejecucion.py:133:    params = (CIERRE_IMPUTE_SOURCE, ejecucion_id)
  scripts\postprocess_ejecucion.py:134:    cur.execute(sql, params)
  scripts\postprocess_ejecucion.py:135:    count = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:136:    print(f"  - Corrected mid-call CIERRE: {count} rows")
  scripts\postprocess_ejecucion.py:137:    return count
  scripts\postprocess_ejecucion.py:138:
  scripts\postprocess_ejecucion.py:139:def cierre_backfill_when_has_next(cur, ejecucion_id, do_write, verbose):
  scripts\postprocess_ejecucion.py:140:    """Busca hacia atrás una fase válida para 'CIERRE' en mitad de llamada."""
  scripts\postprocess_ejecucion.py:141:    print("\n5) Backfilling mid-call CIERRE from nearest valid past turn...")
  scripts\postprocess_ejecucion.py:142:    sql = """
  scripts\postprocess_ejecucion.py:143:    UPDATE sa_turnos t
  scripts\postprocess_ejecucion.py:144:    JOIN sa_turnos t_next ON t.conversacion_pk = t_next.conversacion_pk AND t.turno_idx = t_next.turno_idx - 1
  scripts\postprocess_ejecucion.py:145:    JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
  scripts\postprocess_ejecucion.py:146:    JOIN (
  scripts\postprocess_ejecucion.py:147:        SELECT t_sub.turno_pk, 
> scripts\postprocess_ejecucion.py:148:               (SELECT t_past.fase 
  scripts\postprocess_ejecucion.py:149:                FROM sa_turnos t_past
  scripts\postprocess_ejecucion.py:150:                WHERE t_past.conversacion_pk = t_sub.conversacion_pk AND t_past.turno_idx < t_sub.turno_idx
> scripts\postprocess_ejecucion.py:151:                  AND t_past.fase IS NOT NULL AND TRIM(t_past.fase) <> '' AND t_past.fase <> 'CIERRE'
  scripts\postprocess_ejecucion.py:152:                ORDER BY t_past.turno_idx DESC 
  scripts\postprocess_ejecucion.py:153:                LIMIT 1) as prev_fase
  scripts\postprocess_ejecucion.py:154:        FROM sa_turnos t_sub
  scripts\postprocess_ejecucion.py:155:    ) as prev_data ON t.turno_pk = prev_data.turno_pk
> scripts\postprocess_ejecucion.py:156:    SET t.fase = prev_data.prev_fase, t.fase_source = %s
  scripts\postprocess_ejecucion.py:157:    WHERE c.ejecucion_id = %s
> scripts\postprocess_ejecucion.py:158:      AND t.fase = 'CIERRE'
  scripts\postprocess_ejecucion.py:159:      AND prev_data.prev_fase IS NOT NULL
  scripts\postprocess_ejecucion.py:160:    """
  scripts\postprocess_ejecucion.py:161:    params = (CIERRE_BACKFILL_SOURCE, ejecucion_id)
  scripts\postprocess_ejecucion.py:162:    cur.execute(sql, params)
  scripts\postprocess_ejecucion.py:163:    count = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:164:    print(f"  - Backfilled mid-call CIERRE: {count} rows")
  scripts\postprocess_ejecucion.py:165:    return count
  scripts\postprocess_ejecucion.py:166:
  scripts\postprocess_ejecucion.py:167:def fix_turno1_cierre(cur, ejecucion_id, do_write, verbose):
  scripts\postprocess_ejecucion.py:168:    """Corrige 'CIERRE' en turno 1 si el turno 2 tiene fase válida."""
  scripts\postprocess_ejecucion.py:169:    print("\n6) Fixing CIERRE at turn 1...")
  scripts\postprocess_ejecucion.py:170:    sql = """
  scripts\postprocess_ejecucion.py:171:    UPDATE sa_turnos t
  scripts\postprocess_ejecucion.py:172:    JOIN sa_turnos t2 ON t.conversacion_pk = t2.conversacion_pk AND t2.turno_idx = 2
  scripts\postprocess_ejecucion.py:173:    JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
> scripts\postprocess_ejecucion.py:174:    SET t.fase = t2.fase, t.fase_source = %s
  scripts\postprocess_ejecucion.py:175:    WHERE c.ejecucion_id = %s
> scripts\postprocess_ejecucion.py:176:      AND t.turno_idx = 1 AND t.fase = 'CIERRE'
  scripts\postprocess_ejecucion.py:177:      AND t2.fase IS NOT NULL AND TRIM(t2.fase) <> ''
  scripts\postprocess_ejecucion.py:178:    """
  scripts\postprocess_ejecucion.py:179:    params = (CIERRE_FIX1_SOURCE, ejecucion_id)
  scripts\postprocess_ejecucion.py:180:    cur.execute(sql, params)
  scripts\postprocess_ejecucion.py:181:    count = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:182:    print(f"  - Fixed CIERRE at turn 1: {count} rows")
  scripts\postprocess_ejecucion.py:183:    return count
  scripts\postprocess_ejecucion.py:184:
  scripts\postprocess_ejecucion.py:185:def ensure_and_update_fase_8(cur, ejecucion_id, mapeo_version, do_write, verbose):
  scripts\postprocess_ejecucion.py:186:    """Asegura que la columna fase_8 exista y la actualiza."""
  scripts\postprocess_ejecucion.py:187:    print("\n7) Updating fase_8...")
  scripts\postprocess_ejecucion.py:188:    
  scripts\postprocess_ejecucion.py:189:    # Verificar si la columna existe
  scripts\postprocess_ejecucion.py:190:    cur.execute("SHOW COLUMNS FROM sa_turnos LIKE 'fase_8'")
  scripts\postprocess_ejecucion.py:191:    column_exists = cur.fetchone() is not None
  scripts\postprocess_ejecucion.py:192:    
  scripts\postprocess_ejecucion.py:193:    if not column_exists:
  scripts\postprocess_ejecucion.py:194:        if not do_write:
  scripts\postprocess_ejecucion.py:195:            print("  - WARNING: Column 'fase_8' does not exist and --write not specified. Skipping fase_8 update.")
  scripts\postprocess_ejecucion.py:196:            return 0
  scripts\postprocess_ejecucion.py:197:        # Crear columna solo en modo write
  scripts\postprocess_ejecucion.py:198:        cur.execute("ALTER TABLE sa_turnos ADD COLUMN fase_8 VARCHAR(64) NULL AFTER fase")
  scripts\postprocess_ejecucion.py:199:        print("  - Column 'fase_8' created.")
  scripts\postprocess_ejecucion.py:200:    elif verbose:
  scripts\postprocess_ejecucion.py:201:        print("  - Column 'fase_8' already exists.")
  scripts\postprocess_ejecucion.py:202:    
  scripts\postprocess_ejecucion.py:203:    # Actualizar fase_8 usando el mapeo
  scripts\postprocess_ejecucion.py:204:    sql_map = """
  scripts\postprocess_ejecucion.py:205:    UPDATE sa_turnos t
  scripts\postprocess_ejecucion.py:206:    JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
> scripts\postprocess_ejecucion.py:207:    LEFT JOIN fase_mapeo_oficial m ON t.fase = m.fase_vieja_id AND m.version = %s AND m.activo = 1
  scripts\postprocess_ejecucion.py:208:    SET t.fase_8 = m.fase_nueva_id
  scripts\postprocess_ejecucion.py:209:    WHERE c.ejecucion_id = %s
  scripts\postprocess_ejecucion.py:210:    """
  scripts\postprocess_ejecucion.py:211:    params = (mapeo_version, ejecucion_id)
  scripts\postprocess_ejecucion.py:212:    cur.execute(sql_map, params)
  scripts\postprocess_ejecucion.py:213:    count_map = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:214:    print(f"  - Mapped fase_8 from fase_mapeo_oficial: {count_map} rows")
  scripts\postprocess_ejecucion.py:215:
  scripts\postprocess_ejecucion.py:216:    # Setear 'NOISE' en los nulos restantes
  scripts\postprocess_ejecucion.py:217:    sql_noise = """
  scripts\postprocess_ejecucion.py:218:    UPDATE sa_turnos t
  scripts\postprocess_ejecucion.py:219:    JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
  scripts\postprocess_ejecucion.py:220:    SET t.fase_8 = 'NOISE'
  scripts\postprocess_ejecucion.py:221:    WHERE c.ejecucion_id = %s
  scripts\postprocess_ejecucion.py:222:      AND (t.fase_8 IS NULL OR TRIM(t.fase_8) = '')
  scripts\postprocess_ejecucion.py:223:    """
  scripts\postprocess_ejecucion.py:224:    params_noise = (ejecucion_id,)
  scripts\postprocess_ejecucion.py:225:    cur.execute(sql_noise, params_noise)
  scripts\postprocess_ejecucion.py:226:    count_noise = cur.rowcount or 0
  scripts\postprocess_ejecucion.py:227:    print(f"  - Set remaining fase_8 to NOISE: {count_noise} rows")
  scripts\postprocess_ejecucion.py:228:    return count_map + count_noise
  scripts\postprocess_ejecucion.py:229:
  scripts\postprocess_ejecucion.py:230:def show_metrics(cur, ejecucion_id):
  scripts\postprocess_ejecucion.py:231:    """Imprime métricas de calidad y estado final."""
  scripts\postprocess_ejecucion.py:232:    print("\n8) Final Metrics:")
  scripts\postprocess_ejecucion.py:233:
  scripts\postprocess_ejecucion.py:234:    # Conteo por fase_source
  scripts\postprocess_ejecucion.py:235:    print("\n  - Counts by fase_source:")
  scripts\postprocess_ejecucion.py:236:    cur.execute("""
  scripts\postprocess_ejecucion.py:237:        SELECT fase_source, COUNT(*) as n, SUM(CASE WHEN fase IS NULL OR TRIM(fase) = '' THEN 1 ELSE 0 END) as fase_null
  scripts\postprocess_ejecucion.py:238:        FROM sa_turnos t
  scripts\postprocess_ejecucion.py:239:        JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
  scripts\postprocess_ejecucion.py:240:        WHERE c.ejecucion_id = %s
  scripts\postprocess_ejecucion.py:241:        GROUP BY fase_source
  scripts\postprocess_ejecucion.py:242:        ORDER BY fase_source
  scripts\postprocess_ejecucion.py:243:    """, (ejecucion_id,))
  scripts\postprocess_ejecucion.py:244:    for row in cur.fetchall():
  scripts\postprocess_ejecucion.py:245:        print(f"    - {row[0] or 'NULL':<20}: n={row[1]:<6}, fase_null={row[2]}")
  scripts\postprocess_ejecucion.py:246:
  scripts\postprocess_ejecucion.py:247:    # NOISE y fase nulos (separados)
  scripts\postprocess_ejecucion.py:248:    cur.execute("""
  scripts\postprocess_ejecucion.py:249:        SELECT COUNT(*) FROM sa_turnos t
  scripts\postprocess_ejecucion.py:250:        JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
  scripts\postprocess_ejecucion.py:251:        WHERE c.ejecucion_id = %s AND t.fase_source = 'NOISE'
  scripts\postprocess_ejecucion.py:252:    """, (ejecucion_id,))
  scripts\postprocess_ejecucion.py:253:    noise_turns = cur.fetchone()[0]
  scripts\postprocess_ejecucion.py:254:    
  scripts\postprocess_ejecucion.py:255:    cur.execute("""
  scripts\postprocess_ejecucion.py:256:        SELECT COUNT(*) FROM sa_turnos t
  scripts\postprocess_ejecucion.py:257:        JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
> scripts\postprocess_ejecucion.py:258:        WHERE c.ejecucion_id = %s AND (t.fase IS NULL OR TRIM(t.fase) = '')
  scripts\postprocess_ejecucion.py:259:    """, (ejecucion_id,))
  scripts\postprocess_ejecucion.py:260:    fase_null_turns = cur.fetchone()[0]
  scripts\postprocess_ejecucion.py:261:    
  scripts\postprocess_ejecucion.py:262:    print(f"\n  - Turns with fase_source='NOISE': {noise_turns}")
  scripts\postprocess_ejecucion.py:263:    print(f"  - Turns with NULL or empty fase: {fase_null_turns}")
  scripts\postprocess_ejecucion.py:264:
  scripts\postprocess_ejecucion.py:265:    # fase_8 nulos
  scripts\postprocess_ejecucion.py:266:    cur.execute("""
  scripts\postprocess_ejecucion.py:267:        SELECT COUNT(*) FROM sa_turnos t
  scripts\postprocess_ejecucion.py:268:        JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
  scripts\postprocess_ejecucion.py:269:        WHERE c.ejecucion_id = %s AND (t.fase_8 IS NULL OR TRIM(t.fase_8) = '')
  scripts\postprocess_ejecucion.py:270:    """, (ejecucion_id,))
  scripts\postprocess_ejecucion.py:271:    print(f"  - Null/empty fase_8 turns: {cur.fetchone()[0]}")
  scripts\postprocess_ejecucion.py:272:
  scripts\postprocess_ejecucion.py:273:    # Violaciones de secuencia
  scripts\postprocess_ejecucion.py:274:    print("\n  - Final sequence violations:")
  scripts\postprocess_ejecucion.py:275:    sql_violations = """
  scripts\postprocess_ejecucion.py:276:    WITH fase_orden AS (
  scripts\postprocess_ejecucion.py:277:        SELECT 'APERTURA' as fase, 1 as orden UNION ALL
  scripts\postprocess_ejecucion.py:278:        SELECT 'IDENTIFICACIÓN', 2 UNION ALL
  scripts\postprocess_ejecucion.py:279:        SELECT 'IDENTIFICACION', 2 UNION ALL
  scripts\postprocess_ejecucion.py:280:        SELECT 'INFORMACIÓN_DEUDA', 3 UNION ALL
  scripts\postprocess_ejecucion.py:281:        SELECT 'INFORMACION_DEUDA', 3 UNION ALL
  scripts\postprocess_ejecucion.py:282:        SELECT 'NEGOCIACIÓN', 4 UNION ALL
  scripts\postprocess_ejecucion.py:283:        SELECT 'NEGOCIACION', 4 UNION ALL
  scripts\postprocess_ejecucion.py:284:        SELECT 'CONSULTA_ACEPTACIÓN', 5 UNION ALL
  scripts\postprocess_ejecucion.py:285:        SELECT 'CONSULTA_ACEPTACION', 5 UNION ALL
  scripts\postprocess_ejecucion.py:286:        SELECT 'FORMALIZACIÓN_PAGO', 6 UNION ALL
  scripts\postprocess_ejecucion.py:287:        SELECT 'FORMALIZACION_PAGO', 6 UNION ALL
  scripts\postprocess_ejecucion.py:288:        SELECT 'ADVERTENCIAS', 7 UNION ALL
  scripts\postprocess_ejecucion.py:289:        SELECT 'CIERRE', 8
  scripts\postprocess_ejecucion.py:290:    ),
  scripts\postprocess_ejecucion.py:291:    turnos_con_orden AS (
  scripts\postprocess_ejecucion.py:292:        SELECT 
> scripts\postprocess_ejecucion.py:293:            t.conversacion_pk, t.turno_idx, t.fase, fo.orden,
> scripts\postprocess_ejecucion.py:294:            LAG(t.fase, 1) OVER (PARTITION BY t.conversacion_pk ORDER BY t.turno_idx) as prev_fase,
  scripts\postprocess_ejecucion.py:295:            LAG(fo.orden, 1) OVER (PARTITION BY t.conversacion_pk ORDER BY t.turno_idx) as prev_orden
  scripts\postprocess_ejecucion.py:296:        FROM sa_turnos t
  scripts\postprocess_ejecucion.py:297:        JOIN sa_conversaciones c ON t.conversacion_pk = c.conversacion_pk
> scripts\postprocess_ejecucion.py:298:        LEFT JOIN fase_orden fo ON t.fase = fo.fase
> scripts\postprocess_ejecucion.py:299:        WHERE c.ejecucion_id = %s AND t.fase IS NOT NULL AND TRIM(t.fase) <> ''
  scripts\postprocess_ejecucion.py:300:    )
  scripts\postprocess_ejecucion.py:301:    SELECT prev_fase, fase, COUNT(*) as violations
  scripts\postprocess_ejecucion.py:302:    FROM turnos_con_orden
  scripts\postprocess_ejecucion.py:303:    WHERE prev_orden IS NOT NULL AND orden IS NOT NULL AND orden < prev_orden
  scripts\postprocess_ejecucion.py:304:      -- Excepciones permitidas (con variantes acentuadas)
  scripts\postprocess_ejecucion.py:305:      AND NOT (prev_fase IN ('FORMALIZACION_PAGO', 'FORMALIZACIÓN_PAGO') AND fase IN ('CONSULTA_ACEPTACION', 'CONSULTA_ACEPTACIÓN'))
  scripts\postprocess_ejecucion.py:306:      AND NOT (prev_fase = 'ADVERTENCIAS' AND fase IN ('CONSULTA_ACEPTACION', 'CONSULTA_ACEPTACIÓN'))
  scripts\postprocess_ejecucion.py:307:      AND NOT (prev_fase = 'ADVERTENCIAS' AND fase IN ('FORMALIZACION_PAGO', 'FORMALIZACIÓN_PAGO'))
  scripts\postprocess_ejecucion.py:308:    GROUP BY prev_fase, fase
  scripts\postprocess_ejecucion.py:309:    ORDER BY violations DESC
  scripts\postprocess_ejecucion.py:310:    """
  scripts\postprocess_ejecucion.py:311:    cur.execute(sql_violations, (ejecucion_id,))
  scripts\postprocess_ejecucion.py:312:    violations = cur.fetchall()
  scripts\postprocess_ejecucion.py:313:    if not violations:
  scripts\postprocess_ejecucion.py:314:        print("    - No violations found.")
  scripts\postprocess_ejecucion.py:315:    for prev_fase, fase, count in violations:
  scripts\postprocess_ejecucion.py:316:        print(f"    - {prev_fase} -> {fase}: {count} times")
  scripts\postprocess_ejecucion.py:317:
  scripts\postprocess_ejecucion.py:318:def main():
  scripts\postprocess_ejecucion.py:319:    ap = argparse.ArgumentParser(description="Post-procesa una ejecución con operaciones SQL idempotentes.")
  scripts\postprocess_ejecucion.py:320:    ap.add_argument("--config", default="config.ini", help="Ruta al archivo de configuración.")
  scripts\postprocess_ejecucion.py:321:    ap.add_argument("--ejecucion_id", type=int, required=True, help="ID de la ejecución a procesar.")
  scripts\postprocess_ejecucion.py:322:    ap.add_argument("--mapeo_version", required=True, help="Versión del mapeo en fase_mapeo_oficial.")
  scripts\postprocess_ejecucion.py:323:    ap.add_argument("--write", action="store_true", help="Si se especifica, realiza los cambios en la DB.")
  scripts\postprocess_ejecucion.py:324:    ap.add_argument("--verbose", action="store_true", help="Muestra más detalles en el modo dry-run.")
  scripts\postprocess_ejecucion.py:325:    args = ap.parse_args()
  scripts\postprocess_ejecucion.py:326:
  scripts\postprocess_ejecucion.py:327:    print(f"Starting post-processing for ejecucion_id={args.ejecucion_id}")
  scripts\postprocess_ejecucion.py:328:    if not args.write:
  scripts\postprocess_ejecucion.py:329:        print("--- RUNNING IN DRY-RUN MODE (no updates will be committed) ---")
  scripts\postprocess_ejecucion.py:330:
  scripts\postprocess_ejecucion.py:331:    cfg = load_config(args.config)
  scripts\postprocess_ejecucion.py:332:    conn = get_conn(cfg)
  scripts\postprocess_ejecucion.py:333:    
  scripts\postprocess_ejecucion.py:334:    total_updated = 0
  scripts\postprocess_ejecucion.py:335:
  scripts\postprocess_ejecucion.py:336:    try:
  scripts\postprocess_ejecucion.py:337:        with transaction(conn, args.write) as cur:
  scripts\postprocess_ejecucion.py:338:            total_updated += noise_impute_prev_next(cur, args.ejecucion_id, args.write, args.verbose)
  scripts\postprocess_ejecucion.py:339:            total_updated += apertura_midcall_impute_prev(cur, args.ejecucion_id, args.write, args.verbose)
  scripts\postprocess_ejecucion.py:340:            total_updated += apertura_midcall_backfill_when_has_next(cur, args.ejecucion_id, args.write, args.verbose)
  scripts\postprocess_ejecucion.py:341:            total_updated += cierre_midcall_impute_prev_when_has_next(cur, args.ejecucion_id, args.write, args.verbose)
  scripts\postprocess_ejecucion.py:342:            total_updated += cierre_backfill_when_has_next(cur, args.ejecucion_id, args.write, args.verbose)
  scripts\postprocess_ejecucion.py:343:            total_updated += fix_turno1_cierre(cur, args.ejecucion_id, args.write, args.verbose)
  scripts\postprocess_ejecucion.py:344:            total_updated += ensure_and_update_fase_8(cur, args.ejecucion_id, args.mapeo_version, args.write, args.verbose)
  scripts\postprocess_ejecucion.py:345:            
  scripts\postprocess_ejecucion.py:346:            # Las métricas se muestran siempre, incluso en dry-run, sobre el estado potencial
  scripts\postprocess_ejecucion.py:347:            show_metrics(cur, args.ejecucion_id)
  scripts\postprocess_ejecucion.py:348:
  scripts\postprocess_ejecucion.py:349:    finally:
  scripts\postprocess_ejecucion.py:350:        conn.close()
  scripts\postprocess_ejecucion.py:351:
  scripts\postprocess_ejecucion.py:352:    print(f"\nProcess finished. Total rows affected (in {('write' if args.write else 'dry-run')} mode): {total_updated}")
  scripts\postprocess_ejecucion.py:353:
  scripts\postprocess_ejecucion.py:354:if __name__ == "__main__":
  scripts\postprocess_ejecucion.py:355:    main()
> scripts\reclasificar_turnos_deepseek.py:52:    Carga el prompt desde prompts/deepseek_prompt.txt.
  scripts\reclasificar_turnos_deepseek.py:53:    Retorna (system_msg_template, user_msg_template) o None si no existe.
  scripts\reclasificar_turnos_deepseek.py:54:    """
> scripts\reclasificar_turnos_deepseek.py:55:    prompt_file = Path("prompts/deepseek_prompt.txt")
  scripts\reclasificar_turnos_deepseek.py:56:    if not prompt_file.exists():
  scripts\reclasificar_turnos_deepseek.py:57:        return None
  scripts\reclasificar_turnos_deepseek.py:58:    
  scripts\reclasificar_turnos_deepseek.py:59:    try:
  scripts\reclasificar_turnos_deepseek.py:60:        content = prompt_file.read_text(encoding="utf-8")
  scripts\reclasificar_turnos_deepseek.py:61:        
  scripts\reclasificar_turnos_deepseek.py:62:        # Parsear formato: SYSTEM_MESSAGE: ... USER_MESSAGE_TEMPLATE: ...
  scripts\reclasificar_turnos_deepseek.py:63:        system_msg = ""
  scripts\reclasificar_turnos_deepseek.py:64:        user_msg = ""
  scripts\reclasificar_turnos_deepseek.py:65:        
  scripts\reclasificar_turnos_deepseek.py:66:        if "SYSTEM_MESSAGE:" in content and "USER_MESSAGE_TEMPLATE:" in content:
  scripts\reclasificar_turnos_deepseek.py:67:            parts = content.split("USER_MESSAGE_TEMPLATE:")
  scripts\reclasificar_turnos_deepseek.py:68:            system_part = parts[0].replace("SYSTEM_MESSAGE:", "").strip()
  scripts\reclasificar_turnos_deepseek.py:69:            user_part = parts[1].strip()
  scripts\reclasificar_turnos_deepseek.py:70:            system_msg = system_part
  scripts\reclasificar_turnos_deepseek.py:71:            user_msg = user_part
  scripts\reclasificar_turnos_deepseek.py:72:        else:
  scripts\reclasificar_turnos_deepseek.py:73:            # Fallback: usar todo como user message
  scripts\reclasificar_turnos_deepseek.py:74:            user_msg = content.strip()
  scripts\reclasificar_turnos_deepseek.py:75:        
  scripts\reclasificar_turnos_deepseek.py:76:        return system_msg, user_msg
  scripts\reclasificar_turnos_deepseek.py:77:    except Exception as e:
  scripts\reclasificar_turnos_deepseek.py:78:        print(f"[WARN] Error cargando prompt desde archivo: {e}")
  scripts\reclasificar_turnos_deepseek.py:79:        return None
  scripts\reclasificar_turnos_deepseek.py:80:
  scripts\reclasificar_turnos_deepseek.py:81:def _build_llm_prompts(context_block: str, last_phase_info: str, allowed_phases: list[str]) -> tuple[str, str]:
  scripts\reclasificar_turnos_deepseek.py:82:    phases_list = ", ".join(allowed_phases)
  scripts\reclasificar_turnos_deepseek.py:83:    
  scripts\reclasificar_turnos_deepseek.py:84:    # Intentar cargar desde archivo
  scripts\reclasificar_turnos_deepseek.py:85:    template = _load_prompt_template()
  scripts\reclasificar_turnos_deepseek.py:86:    
  scripts\reclasificar_turnos_deepseek.py:87:    if template:
  scripts\reclasificar_turnos_deepseek.py:88:        system_template, user_template = template
  scripts\reclasificar_turnos_deepseek.py:89:        
  scripts\reclasificar_turnos_deepseek.py:90:        # Si system_template está vacío, usar default
  scripts\reclasificar_turnos_deepseek.py:91:        if not system_template:
  scripts\reclasificar_turnos_deepseek.py:92:            system_msg = "Eres un clasificador de fases de cobranzas. Devuelve SOLO JSON válido y estricto, sin texto adicional."
  scripts\reclasificar_turnos_deepseek.py:93:        else:
  scripts\reclasificar_turnos_deepseek.py:94:            system_msg = system_template
  scripts\reclasificar_turnos_deepseek.py:95:        
  scripts\reclasificar_turnos_deepseek.py:96:        # Reemplazar placeholders en user_template
  scripts\reclasificar_turnos_deepseek.py:97:        user_msg = user_template.format(
  scripts\reclasificar_turnos_deepseek.py:98:            phases_list=phases_list,
  scripts\reclasificar_turnos_deepseek.py:99:            last_phase_info=last_phase_info,
  scripts\reclasificar_turnos_deepseek.py:100:            context_block=context_block
  scripts\reclasificar_turnos_deepseek.py:101:        )
  scripts\reclasificar_turnos_deepseek.py:102:    else:
  scripts\reclasificar_turnos_deepseek.py:103:        # FALLBACK: Prompt hardcodeado (comportamiento original)
  scripts\reclasificar_turnos_deepseek.py:104:        rules = (
  scripts\reclasificar_turnos_deepseek.py:105:            "Reglas estrictas de salida:\n"
  scripts\reclasificar_turnos_deepseek.py:106:            "- Devuelve SOLO JSON exacto: {\"fase_id\": \"...\", \"confidence\": 0.xx, \"is_noise\": true|false}.\n"
  scripts\reclasificar_turnos_deepseek.py:107:            "- Si 'is_noise' es true => 'fase_id' debe ser null.\n"
  scripts\reclasificar_turnos_deepseek.py:108:            "- Si 'is_noise' es false => 'fase_id' debe ser EXACTAMENTE una de las fases permitidas.\n"
  scripts\reclasificar_turnos_deepseek.py:109:            "- PROHIBIDO devolver fases viejas/legacy.\n"
  scripts\reclasificar_turnos_deepseek.py:110:            "- Confidence en rango 0..1.\n"
  scripts\reclasificar_turnos_deepseek.py:111:        )
  scripts\reclasificar_turnos_deepseek.py:112:        system_msg = "Eres un clasificador de fases de cobranzas. Devuelve SOLO JSON válido y estricto, sin texto adicional."
  scripts\reclasificar_turnos_deepseek.py:113:        user_msg = (
  scripts\reclasificar_turnos_deepseek.py:114:            f"Fases permitidas: {phases_list}\n\n"
  scripts\reclasificar_turnos_deepseek.py:115:            f"{rules}\n"
  scripts\reclasificar_turnos_deepseek.py:116:            f"Estado previo: {last_phase_info}\n"
  scripts\reclasificar_turnos_deepseek.py:117:            f"Contexto:\n{context_block}\n\n"
  scripts\reclasificar_turnos_deepseek.py:118:            "Salida EXACTA JSON: {\"fase_id\": \"OFERTA_PAGO\", \"confidence\": 0.82, \"is_noise\": false}"
  scripts\reclasificar_turnos_deepseek.py:119:        )
  scripts\reclasificar_turnos_deepseek.py:120:    
  scripts\reclasificar_turnos_deepseek.py:121:    return system_msg, user_msg
  scripts\reclasificar_turnos_deepseek.py:122:
> scripts\reclasificar_turnos_deepseek.py:123:def call_deepseek(text: str, prev_fase: str|None, next_fase: str|None, turn_idx: int, total_turns: int,
  scripts\reclasificar_turnos_deepseek.py:124:                 base_url: str, api_key: str, model: str, timeout: int = 60, context_block: str | None = None,
  scripts\reclasificar_turnos_deepseek.py:125:                 last_phase_info: str = "last_phase=None conf=None source=None", allowed_phases: list[str] | None = None) -> dict:
  scripts\reclasificar_turnos_deepseek.py:126:    url = _chat_completions_url(base_url)
  scripts\reclasificar_turnos_deepseek.py:127:    if context_block is None:
  scripts\reclasificar_turnos_deepseek.py:128:        # si no hay bloque de contexto, armar uno mínimo con el texto objetivo
  scripts\reclasificar_turnos_deepseek.py:129:        _san = text[:280].replace('\r', ' ').replace('\n', ' ')
  scripts\reclasificar_turnos_deepseek.py:130:        context_block = (
  scripts\reclasificar_turnos_deepseek.py:131:            f"Turno idx=-2: (no disponible)\n"
  scripts\reclasificar_turnos_deepseek.py:132:            f"Turno idx=-1: (no disponible)\n"
  scripts\reclasificar_turnos_deepseek.py:133:            f"Turno idx=0 (OBJETIVO): {_san}\n"
  scripts\reclasificar_turnos_deepseek.py:134:            f"Turno idx=+1: (no disponible)"
  scripts\reclasificar_turnos_deepseek.py:135:        )
  scripts\reclasificar_turnos_deepseek.py:136:
  scripts\reclasificar_turnos_deepseek.py:137:    sys, usr = _build_llm_prompts(context_block, last_phase_info, allowed_phases or [])
  scripts\reclasificar_turnos_deepseek.py:138:
  scripts\reclasificar_turnos_deepseek.py:139:    payload = {
  scripts\reclasificar_turnos_deepseek.py:140:        "model": model,
  scripts\reclasificar_turnos_deepseek.py:141:        "messages": [
  scripts\reclasificar_turnos_deepseek.py:142:            {"role": "system", "content": sys},
  scripts\reclasificar_turnos_deepseek.py:143:            {"role": "user", "content": usr}
  scripts\reclasificar_turnos_deepseek.py:144:        ],
  scripts\reclasificar_turnos_deepseek.py:145:        "temperature": 0.0,
  scripts\reclasificar_turnos_deepseek.py:146:    }
  scripts\reclasificar_turnos_deepseek.py:147:
  scripts\reclasificar_turnos_deepseek.py:148:    if not api_key:
> scripts\reclasificar_turnos_deepseek.py:149:        raise ValueError("api_key for DeepSeek cannot be empty")
  scripts\reclasificar_turnos_deepseek.py:150:
  scripts\reclasificar_turnos_deepseek.py:151:    if not api_key:
> scripts\reclasificar_turnos_deepseek.py:152:        raise ValueError("api_key for DeepSeek cannot be empty")
  scripts\reclasificar_turnos_deepseek.py:153:
  scripts\reclasificar_turnos_deepseek.py:154:    headers = {
  scripts\reclasificar_turnos_deepseek.py:155:        "Authorization": f"Bearer {api_key}",
  scripts\reclasificar_turnos_deepseek.py:156:        "Content-Type": "application/json",
  scripts\reclasificar_turnos_deepseek.py:157:    }
  scripts\reclasificar_turnos_deepseek.py:158:
  scripts\reclasificar_turnos_deepseek.py:159:    r = requests.post(url, headers=headers, json=payload, timeout=timeout)
  scripts\reclasificar_turnos_deepseek.py:160:    r.raise_for_status()
  scripts\reclasificar_turnos_deepseek.py:161:    data = r.json()
  scripts\reclasificar_turnos_deepseek.py:162:
  scripts\reclasificar_turnos_deepseek.py:163:    content = data["choices"][0]["message"]["content"]
  scripts\reclasificar_turnos_deepseek.py:164:    m = JSON_RE.search(content)
  scripts\reclasificar_turnos_deepseek.py:165:    if not m:
  scripts\reclasificar_turnos_deepseek.py:166:        raise ValueError(f"No JSON found in response content: {content[:200]}")
  scripts\reclasificar_turnos_deepseek.py:167:    obj = json.loads(m.group(0))
  scripts\reclasificar_turnos_deepseek.py:168:
  scripts\reclasificar_turnos_deepseek.py:169:    raw_fase = (obj.get("fase_id") or obj.get("fase") or "").strip()
  scripts\reclasificar_turnos_deepseek.py:170:    fase = _normalize_phase_id(raw_fase)
  scripts\reclasificar_turnos_deepseek.py:171:    conf = obj.get("confidence", obj.get("conf", 0.0))
  scripts\reclasificar_turnos_deepseek.py:172:    # is_noise may be bool or int
  scripts\reclasificar_turnos_deepseek.py:173:    _is_noise_val = obj.get("is_noise", False)
  scripts\reclasificar_turnos_deepseek.py:174:    try:
  scripts\reclasificar_turnos_deepseek.py:175:        is_noise = 1 if (bool(_is_noise_val)) else 0
  scripts\reclasificar_turnos_deepseek.py:176:    except Exception:
  scripts\reclasificar_turnos_deepseek.py:177:        is_noise = int(_is_noise_val or 0)
  scripts\reclasificar_turnos_deepseek.py:178:    noise_reason = (obj.get("noise_reason") or "")
  scripts\reclasificar_turnos_deepseek.py:179:    rationale = (obj.get("rationale") or "")
  scripts\reclasificar_turnos_deepseek.py:180:    try:
  scripts\reclasificar_turnos_deepseek.py:181:        conf = float(conf)
  scripts\reclasificar_turnos_deepseek.py:182:    except Exception:
  scripts\reclasificar_turnos_deepseek.py:183:        conf = 0.0
  scripts\reclasificar_turnos_deepseek.py:184:
  scripts\reclasificar_turnos_deepseek.py:185:    # Do not validate against legacy phases here; normalization happens later
  scripts\reclasificar_turnos_deepseek.py:186:    conf = max(0.0, min(1.0, conf))
  scripts\reclasificar_turnos_deepseek.py:187:    return {"fase": fase, "conf": conf, "raw": content, "is_noise": is_noise, "noise_reason": noise_reason, "rationale": rationale}
  scripts\reclasificar_turnos_deepseek.py:188:
  scripts\reclasificar_turnos_deepseek.py:189:def load_allowed_phases(conn) -> list[str]:
  scripts\reclasificar_turnos_deepseek.py:190:    cur = conn.cursor()
  scripts\reclasificar_turnos_deepseek.py:191:    cur.execute("SELECT fase_id FROM fases_conversacion")
  scripts\reclasificar_turnos_deepseek.py:192:    rows = cur.fetchall()
  scripts\reclasificar_turnos_deepseek.py:193:    cur.close()
  scripts\reclasificar_turnos_deepseek.py:194:    out = []
  scripts\reclasificar_turnos_deepseek.py:195:    for r in rows:
  scripts\reclasificar_turnos_deepseek.py:196:        fase_id = _normalize_phase_id(r[0] or "")
  scripts\reclasificar_turnos_deepseek.py:197:        if fase_id:
  scripts\reclasificar_turnos_deepseek.py:198:            out.append(fase_id)
  scripts\reclasificar_turnos_deepseek.py:199:    return out
  scripts\reclasificar_turnos_deepseek.py:200:
  scripts\reclasificar_turnos_deepseek.py:201:def load_phase_mapping(conn, version: str = "v1.0"):
  scripts\reclasificar_turnos_deepseek.py:202:    """Load official mapping from old phases to allowed phases with regex/default criteria."""
  scripts\reclasificar_turnos_deepseek.py:203:    cur = conn.cursor()
  scripts\reclasificar_turnos_deepseek.py:204:    cur.execute(
  scripts\reclasificar_turnos_deepseek.py:205:        """
  scripts\reclasificar_turnos_deepseek.py:206:        SELECT fase_vieja_id, fase_nueva_id, criterio, patron, prioridad
  scripts\reclasificar_turnos_deepseek.py:207:        FROM fase_mapeo_oficial
  scripts\reclasificar_turnos_deepseek.py:208:        WHERE version=%s AND activo=1
  scripts\reclasificar_turnos_deepseek.py:209:        ORDER BY fase_vieja_id, prioridad
  scripts\reclasificar_turnos_deepseek.py:210:        """,
  scripts\reclasificar_turnos_deepseek.py:211:        (version,)
  scripts\reclasificar_turnos_deepseek.py:212:    )
  scripts\reclasificar_turnos_deepseek.py:213:    rows = cur.fetchall()
  scripts\reclasificar_turnos_deepseek.py:214:    cur.close()
  scripts\reclasificar_turnos_deepseek.py:215:    mapping = {}
  scripts\reclasificar_turnos_deepseek.py:216:    for old_id, new_id, criterio, patron, prioridad in rows:
  scripts\reclasificar_turnos_deepseek.py:217:        old_norm = _normalize_phase_id(old_id or "")
  scripts\reclasificar_turnos_deepseek.py:218:        new_norm = _normalize_phase_id(new_id or "")
  scripts\reclasificar_turnos_deepseek.py:219:        crit = (criterio or '').upper()
  scripts\reclasificar_turnos_deepseek.py:220:        pat = patron or ''
  scripts\reclasificar_turnos_deepseek.py:221:        try:
  scripts\reclasificar_turnos_deepseek.py:222:            regex = re.compile(pat, re.I) if crit == 'REGEX' and pat else None
  scripts\reclasificar_turnos_deepseek.py:223:        except Exception:
  scripts\reclasificar_turnos_deepseek.py:224:            regex = None
  scripts\reclasificar_turnos_deepseek.py:225:        entry = {
  scripts\reclasificar_turnos_deepseek.py:226:            'new': new_norm,
  scripts\reclasificar_turnos_deepseek.py:227:            'criterio': crit,
  scripts\reclasificar_turnos_deepseek.py:228:            'patron': pat,
  scripts\reclasificar_turnos_deepseek.py:229:            'regex': regex,
  scripts\reclasificar_turnos_deepseek.py:230:            'prioridad': int(prioridad or 0),
  scripts\reclasificar_turnos_deepseek.py:231:        }
  scripts\reclasificar_turnos_deepseek.py:232:        mapping.setdefault(old_norm, []).append(entry)
  scripts\reclasificar_turnos_deepseek.py:233:    return mapping
  scripts\reclasificar_turnos_deepseek.py:234:
  scripts\reclasificar_turnos_deepseek.py:235:def normalize_fase(fase_raw: str | None, text: str, allowed_set: set[str], old_set: set[str], mapping: dict) -> str | None:
  scripts\reclasificar_turnos_deepseek.py:236:    f = _normalize_phase_id(fase_raw or '')
  scripts\reclasificar_turnos_deepseek.py:237:    if not f:
  scripts\reclasificar_turnos_deepseek.py:238:        return None
  scripts\reclasificar_turnos_deepseek.py:239:    if f in allowed_set:
  scripts\reclasificar_turnos_deepseek.py:240:        return f
  scripts\reclasificar_turnos_deepseek.py:241:    if f in old_set:
  scripts\reclasificar_turnos_deepseek.py:242:        rules = mapping.get(f, [])
  scripts\reclasificar_turnos_deepseek.py:243:        default_target = None
  scripts\reclasificar_turnos_deepseek.py:244:        for r in rules:
  scripts\reclasificar_turnos_deepseek.py:245:            if r['criterio'] == 'REGEX' and r['regex'] is not None:
  scripts\reclasificar_turnos_deepseek.py:246:                if r['regex'].search(text or ''):
  scripts\reclasificar_turnos_deepseek.py:247:                    return r['new'] if r['new'] in allowed_set else None
  scripts\reclasificar_turnos_deepseek.py:248:            elif r['criterio'] == 'DEFAULT':
  scripts\reclasificar_turnos_deepseek.py:249:                default_target = r['new']
  scripts\reclasificar_turnos_deepseek.py:250:        if default_target and default_target in allowed_set:
  scripts\reclasificar_turnos_deepseek.py:251:            return default_target
  scripts\reclasificar_turnos_deepseek.py:252:        return None
  scripts\reclasificar_turnos_deepseek.py:253:    # Unknown phase -> invalid
  scripts\reclasificar_turnos_deepseek.py:254:    return None
  scripts\reclasificar_turnos_deepseek.py:255:
  scripts\reclasificar_turnos_deepseek.py:256:def update_conversation_final_fields(cur, conv_pks):
  scripts\reclasificar_turnos_deepseek.py:257:    """
  scripts\reclasificar_turnos_deepseek.py:258:    Recalcula fase_final, fase_final_turn_idx y tipo_finalizacion para cada conversacion.
  scripts\reclasificar_turnos_deepseek.py:259:    Marca llm_usado=1.
  scripts\reclasificar_turnos_deepseek.py:260:    """
  scripts\reclasificar_turnos_deepseek.py:261:    for conv_pk in sorted(conv_pks):
  scripts\reclasificar_turnos_deepseek.py:262:        cur.execute(
  scripts\reclasificar_turnos_deepseek.py:263:            """
  scripts\reclasificar_turnos_deepseek.py:264:            SELECT turno_idx, fase
  scripts\reclasificar_turnos_deepseek.py:265:            FROM sa_turnos
  scripts\reclasificar_turnos_deepseek.py:266:            WHERE conversacion_pk=%s AND fase IS NOT NULL AND TRIM(fase)<>''
  scripts\reclasificar_turnos_deepseek.py:267:            ORDER BY turno_idx DESC
  scripts\reclasificar_turnos_deepseek.py:268:            LIMIT 1
  scripts\reclasificar_turnos_deepseek.py:269:            """,
  scripts\reclasificar_turnos_deepseek.py:270:            (conv_pk,)
  scripts\reclasificar_turnos_deepseek.py:271:        )
  scripts\reclasificar_turnos_deepseek.py:272:        row = cur.fetchone()
> scripts\reclasificar_turnos_deepseek.py:312:    api_key = os.getenv("DEEPSEEK_API_KEY", "").strip()
  scripts\reclasificar_turnos_deepseek.py:313:    if not api_key:
> scripts\reclasificar_turnos_deepseek.py:314:        raise SystemExit("Falta DEEPSEEK_API_KEY en el entorno (PowerShell: $env:DEEPSEEK_API_KEY='...')")
  scripts\reclasificar_turnos_deepseek.py:315:
> scripts\reclasificar_turnos_deepseek.py:316:    base_url = os.getenv("DEEPSEEK_BASE_URL", "https://api.deepseek.com").strip()
> scripts\reclasificar_turnos_deepseek.py:317:    model = os.getenv("DEEPSEEK_MODEL", "deepseek-chat").strip()
  scripts\reclasificar_turnos_deepseek.py:318:
  scripts\reclasificar_turnos_deepseek.py:319:    csv_path = args.csv or os.path.join("out_reports", f"run_{args.ejecucion_id}_pendientes_llm.csv")
  scripts\reclasificar_turnos_deepseek.py:320:    if not args.from_db:
  scripts\reclasificar_turnos_deepseek.py:321:        if not os.path.exists(csv_path):
  scripts\reclasificar_turnos_deepseek.py:322:            raise SystemExit(f"No existe CSV: {csv_path}")
  scripts\reclasificar_turnos_deepseek.py:323:
  scripts\reclasificar_turnos_deepseek.py:324:    do_write = bool(args.write) and (not args.dry_run)
  scripts\reclasificar_turnos_deepseek.py:325:
  scripts\reclasificar_turnos_deepseek.py:326:    cfg = load_config(args.config)
  scripts\reclasificar_turnos_deepseek.py:327:    conn = get_conn(cfg)
  scripts\reclasificar_turnos_deepseek.py:328:    cur = conn.cursor()
  scripts\reclasificar_turnos_deepseek.py:329:
  scripts\reclasificar_turnos_deepseek.py:330:    updated_turnos = 0
  scripts\reclasificar_turnos_deepseek.py:331:    touched_convs = set()
  scripts\reclasificar_turnos_deepseek.py:332:    total_turnos_cache = {}
  scripts\reclasificar_turnos_deepseek.py:333:    conv_texts_cache = {}
  scripts\reclasificar_turnos_deepseek.py:334:    ok_high = 0
  scripts\reclasificar_turnos_deepseek.py:335:    ok_low = 0
  scripts\reclasificar_turnos_deepseek.py:336:    noise_written = 0
  scripts\reclasificar_turnos_deepseek.py:337:    skipped_existing = 0
  scripts\reclasificar_turnos_deepseek.py:338:    skipped_non_pending = 0
  scripts\reclasificar_turnos_deepseek.py:339:    heuristic_written = 0
  scripts\reclasificar_turnos_deepseek.py:340:    llm_calls = 0
  scripts\reclasificar_turnos_deepseek.py:341:    selected_rows = 0
  scripts\reclasificar_turnos_deepseek.py:342:    no_text_written = 0
  scripts\reclasificar_turnos_deepseek.py:343:    invalid_phase_mapped_to_noise = 0
  scripts\reclasificar_turnos_deepseek.py:344:    wrote_old_phase = 0
  scripts\reclasificar_turnos_deepseek.py:345:
  scripts\reclasificar_turnos_deepseek.py:346:    # Load allowed phases and mapping
  scripts\reclasificar_turnos_deepseek.py:347:    allowed_list = load_allowed_phases(conn)
  scripts\reclasificar_turnos_deepseek.py:348:    allowed_set = set(allowed_list)
  scripts\reclasificar_turnos_deepseek.py:349:    phase_mapping = load_phase_mapping(conn, args.mapeo_version)
  scripts\reclasificar_turnos_deepseek.py:350:
  scripts\reclasificar_turnos_deepseek.py:351:    def fetch_candidates_from_db(conn, ejecucion_id: int, max_rows: int):
  scripts\reclasificar_turnos_deepseek.py:352:        cur2 = conn.cursor()
  scripts\reclasificar_turnos_deepseek.py:353:        sql = (
  scripts\reclasificar_turnos_deepseek.py:354:            """
  scripts\reclasificar_turnos_deepseek.py:355:            SELECT t.turno_pk, t.conversacion_pk, t.turno_idx, t.text
  scripts\reclasificar_turnos_deepseek.py:356:            FROM sa_turnos t
  scripts\reclasificar_turnos_deepseek.py:357:            JOIN sa_conversaciones c ON c.conversacion_pk=t.conversacion_pk
  scripts\reclasificar_turnos_deepseek.py:358:            WHERE c.ejecucion_id=%s
> scripts\reclasificar_turnos_deepseek.py:359:              AND (t.fase IS NULL OR TRIM(t.fase)='')
  scripts\reclasificar_turnos_deepseek.py:360:              AND (t.fase_source IS NULL OR TRIM(t.fase_source)='' OR t.fase_source='NO_IMP')
  scripts\reclasificar_turnos_deepseek.py:361:            ORDER BY t.conversacion_pk, t.turno_idx
  scripts\reclasificar_turnos_deepseek.py:362:            LIMIT %s
  scripts\reclasificar_turnos_deepseek.py:363:            """
  scripts\reclasificar_turnos_deepseek.py:364:        )
  scripts\reclasificar_turnos_deepseek.py:365:        cur2.execute(sql, (ejecucion_id, max_rows if (max_rows and max_rows > 0) else 1000000))
  scripts\reclasificar_turnos_deepseek.py:366:        rows = cur2.fetchall()
  scripts\reclasificar_turnos_deepseek.py:367:        cur2.close()
  scripts\reclasificar_turnos_deepseek.py:368:        out = []
  scripts\reclasificar_turnos_deepseek.py:369:        for r in rows:
  scripts\reclasificar_turnos_deepseek.py:370:            out.append({
  scripts\reclasificar_turnos_deepseek.py:371:                "turno_pk": int(r[0]),
  scripts\reclasificar_turnos_deepseek.py:372:                "conv_pk": int(r[1]),
  scripts\reclasificar_turnos_deepseek.py:373:                "turno_idx": int(r[2]),
  scripts\reclasificar_turnos_deepseek.py:374:                "text": (r[3] or ""),
  scripts\reclasificar_turnos_deepseek.py:375:                "prev_fase": None,
  scripts\reclasificar_turnos_deepseek.py:376:                "next_fase": None,
  scripts\reclasificar_turnos_deepseek.py:377:            })
  scripts\reclasificar_turnos_deepseek.py:378:        return out
  scripts\reclasificar_turnos_deepseek.py:379:
  scripts\reclasificar_turnos_deepseek.py:380:    # Build candidate list from CSV or DB
  scripts\reclasificar_turnos_deepseek.py:381:    candidates = []
  scripts\reclasificar_turnos_deepseek.py:382:    mode = "CSV"
  scripts\reclasificar_turnos_deepseek.py:383:    if args.from_db:
  scripts\reclasificar_turnos_deepseek.py:384:        mode = "DB"
  scripts\reclasificar_turnos_deepseek.py:385:        candidates = fetch_candidates_from_db(conn, args.ejecucion_id, args.max_rows)
  scripts\reclasificar_turnos_deepseek.py:386:    else:
  scripts\reclasificar_turnos_deepseek.py:387:        with open(csv_path, "r", encoding="utf-8") as f:
  scripts\reclasificar_turnos_deepseek.py:388:            rd = csv.DictReader(f)
  scripts\reclasificar_turnos_deepseek.py:389:            required = {"turno_pk", "conv_pk", "turno_idx", "text"}
  scripts\reclasificar_turnos_deepseek.py:390:            headers = set(rd.fieldnames or [])
  scripts\reclasificar_turnos_deepseek.py:391:            missing = sorted(required - headers)
  scripts\reclasificar_turnos_deepseek.py:392:            if missing:
  scripts\reclasificar_turnos_deepseek.py:393:                raise SystemExit(f"CSV headers missing: {', '.join(missing)}. Present: {', '.join(rd.fieldnames or [])}")
  scripts\reclasificar_turnos_deepseek.py:394:            for i, row in enumerate(rd, start=1):
  scripts\reclasificar_turnos_deepseek.py:395:                if args.max_rows and i > args.max_rows:
  scripts\reclasificar_turnos_deepseek.py:396:                    break
  scripts\reclasificar_turnos_deepseek.py:397:                candidates.append({
  scripts\reclasificar_turnos_deepseek.py:398:                    "turno_pk": int(row["turno_pk"]),
  scripts\reclasificar_turnos_deepseek.py:399:                    "conv_pk": int(row["conv_pk"]),
  scripts\reclasificar_turnos_deepseek.py:400:                    "turno_idx": int(row["turno_idx"]),
  scripts\reclasificar_turnos_deepseek.py:401:                    "text": (row.get("text") or "").strip(),
  scripts\reclasificar_turnos_deepseek.py:402:                    "prev_fase": (row.get("prev_fase") or None),
  scripts\reclasificar_turnos_deepseek.py:403:                    "next_fase": (row.get("next_fase") or None),
  scripts\reclasificar_turnos_deepseek.py:404:                    "total_turnos_conv": (row.get("total_turnos_conv") or row.get("total_turnos")),
  scripts\reclasificar_turnos_deepseek.py:405:                })
  scripts\reclasificar_turnos_deepseek.py:406:
  scripts\reclasificar_turnos_deepseek.py:407:    selected_rows = len(candidates)
  scripts\reclasificar_turnos_deepseek.py:408:    print(f"[PICK] mode={mode} selected_rows={selected_rows} ejecucion_id={args.ejecucion_id}")
  scripts\reclasificar_turnos_deepseek.py:409:
  scripts\reclasificar_turnos_deepseek.py:410:    for row in candidates:
  scripts\reclasificar_turnos_deepseek.py:411:
  scripts\reclasificar_turnos_deepseek.py:412:            turno_pk = int(row["turno_pk"])
  scripts\reclasificar_turnos_deepseek.py:413:            conv_pk = int(row["conv_pk"])
  scripts\reclasificar_turnos_deepseek.py:414:            turn_idx = int(row["turno_idx"])
  scripts\reclasificar_turnos_deepseek.py:415:            # total_turnos_conv puede no existir en CSV ni en DB.
  scripts\reclasificar_turnos_deepseek.py:416:            val = row.get("total_turnos_conv")
  scripts\reclasificar_turnos_deepseek.py:417:            if val is not None:
  scripts\reclasificar_turnos_deepseek.py:418:                try:
  scripts\reclasificar_turnos_deepseek.py:419:                    total_turns = int(val)
  scripts\reclasificar_turnos_deepseek.py:420:                except Exception:
  scripts\reclasificar_turnos_deepseek.py:421:                    total_turns = get_total_turnos_conv(conn, conv_pk, total_turnos_cache)
  scripts\reclasificar_turnos_deepseek.py:422:            else:
  scripts\reclasificar_turnos_deepseek.py:423:                total_turns = get_total_turnos_conv(conn, conv_pk, total_turnos_cache)
  scripts\reclasificar_turnos_deepseek.py:424:            prev_fase = (row.get("prev_fase") or None)
  scripts\reclasificar_turnos_deepseek.py:425:            next_fase = (row.get("next_fase") or None)
  scripts\reclasificar_turnos_deepseek.py:426:            text = (row.get("text") or "").strip()
  scripts\reclasificar_turnos_deepseek.py:427:
  scripts\reclasificar_turnos_deepseek.py:428:            # NO_TEXT: texto vacío -> marcar y seguir
  scripts\reclasificar_turnos_deepseek.py:429:            if not text or not text.strip():
  scripts\reclasificar_turnos_deepseek.py:430:                print(f"[NO_TEXT] turno_pk={turno_pk}")
  scripts\reclasificar_turnos_deepseek.py:431:                if do_write:
  scripts\reclasificar_turnos_deepseek.py:432:                    cur.execute(
> scripts\reclasificar_turnos_deepseek.py:433:                        "UPDATE sa_turnos SET fase=NULL, fase_conf=NULL, fase_source=%s WHERE turno_pk=%s AND (fase_source IS NULL OR 
TRIM(fase_source)='' OR fase_source='NO_IMP')",
  scripts\reclasificar_turnos_deepseek.py:434:                        ("NO_TEXT", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:435:                    )
  scripts\reclasificar_turnos_deepseek.py:436:                    if cur.rowcount and cur.rowcount > 0:
  scripts\reclasificar_turnos_deepseek.py:437:                        print(f"[WRITE] turno_pk={turno_pk} old=(fase_source={(db_row[2] if 'db_row' in locals() else 'N/A')}) 
new=(fase=NULL,source=NO_TEXT)")
  scripts\reclasificar_turnos_deepseek.py:438:                        no_text_written += 1
  scripts\reclasificar_turnos_deepseek.py:439:                        updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:440:                        touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:441:                    else:
  scripts\reclasificar_turnos_deepseek.py:442:                        skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:443:                continue
  scripts\reclasificar_turnos_deepseek.py:444:
  scripts\reclasificar_turnos_deepseek.py:445:            # Heurística rápida para fillers / muy corto: evitar LLM
  scripts\reclasificar_turnos_deepseek.py:446:            norm_no_space = _strip_diacritics(text).lower().replace(' ', '')
  scripts\reclasificar_turnos_deepseek.py:447:            is_filler = (len(norm_no_space) < 12) or bool(FILLER_RE.match(text.strip().lower()))
  scripts\reclasificar_turnos_deepseek.py:448:            if is_filler:
  scripts\reclasificar_turnos_deepseek.py:449:                conf_heur = 0.50
  scripts\reclasificar_turnos_deepseek.py:450:                fase_heur = prev_fase if (prev_fase and prev_fase.strip()) else "INFORMACION_DEUDA"
  scripts\reclasificar_turnos_deepseek.py:451:                fase_heur_norm = normalize_fase(fase_heur, text, allowed_set, OLD_PHASES, phase_mapping)
  scripts\reclasificar_turnos_deepseek.py:452:                if do_write:
  scripts\reclasificar_turnos_deepseek.py:453:                    if fase_heur_norm is None:
  scripts\reclasificar_turnos_deepseek.py:454:                        cur.execute(
> scripts\reclasificar_turnos_deepseek.py:455:                            "UPDATE sa_turnos SET fase=NULL, fase_conf=NULL, fase_source=%s WHERE turno_pk=%s AND (fase_source IS NULL OR 
TRIM(fase_source)='' OR fase_source='NO_IMP')",
  scripts\reclasificar_turnos_deepseek.py:456:                            ("NOISE", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:457:                        )
  scripts\reclasificar_turnos_deepseek.py:458:                        if cur.rowcount and cur.rowcount > 0:
  scripts\reclasificar_turnos_deepseek.py:459:                            print(f"[WRITE] turno_pk={turno_pk} old=(source={(db_row[2] if 'db_row' in locals() else 'N/A')}) 
new=(fase=NULL,source=NOISE)")
  scripts\reclasificar_turnos_deepseek.py:460:                            invalid_phase_mapped_to_noise += 1
  scripts\reclasificar_turnos_deepseek.py:461:                            updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:462:                            touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:463:                        else:
  scripts\reclasificar_turnos_deepseek.py:464:                            skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:465:                    else:
  scripts\reclasificar_turnos_deepseek.py:466:                        cur.execute(
> scripts\reclasificar_turnos_deepseek.py:467:                            "UPDATE sa_turnos SET fase=%s, fase_conf=%s, fase_source=%s WHERE turno_pk=%s AND (((fase_source IS NULL OR 
TRIM(fase_source)='') AND (fase IS NULL OR TRIM(fase)='')) OR fase_source='DEEPSEEK_LOW' OR fase_source='NO_IMP')",
  scripts\reclasificar_turnos_deepseek.py:468:                            (fase_heur_norm, round(conf_heur, 4), "HEURISTIC", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:469:                        )
  scripts\reclasificar_turnos_deepseek.py:470:                        if cur.rowcount and cur.rowcount > 0:
  scripts\reclasificar_turnos_deepseek.py:471:                            print(f"[WRITE] turno_pk={turno_pk} old=(source={(db_row[2] if 'db_row' in locals() else 'N/A')}) 
new=(fase={fase_heur_norm},conf={round(conf_heur, 4)},source=HEURISTIC)")
  scripts\reclasificar_turnos_deepseek.py:472:                            heuristic_written += 1
  scripts\reclasificar_turnos_deepseek.py:473:                            updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:474:                            touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:475:                        else:
  scripts\reclasificar_turnos_deepseek.py:476:                            skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:477:                # saltar invocación al LLM
  scripts\reclasificar_turnos_deepseek.py:478:                continue
  scripts\reclasificar_turnos_deepseek.py:479:
> scripts\reclasificar_turnos_deepseek.py:480:            # Idempotencia: consultar estado actual en DB antes de invocar DeepSeek
  scripts\reclasificar_turnos_deepseek.py:481:            cur.execute(
> scripts\reclasificar_turnos_deepseek.py:482:                "SELECT fase, fase_conf, fase_source FROM sa_turnos WHERE turno_pk=%s",
  scripts\reclasificar_turnos_deepseek.py:483:                (turno_pk,)
  scripts\reclasificar_turnos_deepseek.py:484:            )
  scripts\reclasificar_turnos_deepseek.py:485:            db_row = cur.fetchone()
  scripts\reclasificar_turnos_deepseek.py:486:            if db_row:
  scripts\reclasificar_turnos_deepseek.py:487:                fase_db, conf_db, source_db = db_row
  scripts\reclasificar_turnos_deepseek.py:488:                fase_db_s = (fase_db or "").strip()
> scripts\reclasificar_turnos_deepseek.py:489:                if (source_db == "DEEPSEEK") and fase_db_s:
> scripts\reclasificar_turnos_deepseek.py:490:                    print(f"[SKIP_DB] turno_pk={turno_pk} already DEEPSEEK fase={fase_db_s} conf={conf_db if conf_db is not None else 'None'}")
  scripts\reclasificar_turnos_deepseek.py:491:                    skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:492:                    continue
  scripts\reclasificar_turnos_deepseek.py:493:                if fase_db_s and (conf_db is not None) and (float(conf_db) >= args.conf_threshold) and (source_db != 'NO_IMP'):
  scripts\reclasificar_turnos_deepseek.py:494:                    print(f"[SKIP_DB] turno_pk={turno_pk} already has fase={fase_db_s} conf={float(conf_db):.3f} source={(source_db or 'None')}")
  scripts\reclasificar_turnos_deepseek.py:495:                    skipped_non_pending += 1
  scripts\reclasificar_turnos_deepseek.py:496:                    continue
> scripts\reclasificar_turnos_deepseek.py:497:                # No pisar RULES/HEURISTIC/GUARDRAILS (solo permitir DEEPSEEK_LOW/NOISE/NO_IMP o pendiente)
> scripts\reclasificar_turnos_deepseek.py:498:                if fase_db_s and (source_db and source_db.strip()) and (source_db not in ("DEEPSEEK_LOW", "NOISE", "NO_IMP")):
  scripts\reclasificar_turnos_deepseek.py:499:                    print(f"[SKIP_DB] turno_pk={turno_pk} source={source_db} fase={fase_db_s} conf={conf_db if conf_db is not None else 'None'} 
non-pending")
  scripts\reclasificar_turnos_deepseek.py:500:                    skipped_non_pending += 1
  scripts\reclasificar_turnos_deepseek.py:501:                    continue
  scripts\reclasificar_turnos_deepseek.py:502:
  scripts\reclasificar_turnos_deepseek.py:503:            # Cargar cache de conversación completa y construir bloque de contexto idx-3..idx+1 con roles
  scripts\reclasificar_turnos_deepseek.py:504:            def _ensure_conv_texts(conn, conv_pk, cache):
  scripts\reclasificar_turnos_deepseek.py:505:                if conv_pk in cache:
  scripts\reclasificar_turnos_deepseek.py:506:                    return cache[conv_pk]
  scripts\reclasificar_turnos_deepseek.py:507:                cur2 = conn.cursor()
  scripts\reclasificar_turnos_deepseek.py:508:                cur2.execute(
  scripts\reclasificar_turnos_deepseek.py:509:                    "SELECT turno_idx, text FROM sa_turnos WHERE conversacion_pk=%s ORDER BY turno_idx",
  scripts\reclasificar_turnos_deepseek.py:510:                    (conv_pk,)
  scripts\reclasificar_turnos_deepseek.py:511:                )
  scripts\reclasificar_turnos_deepseek.py:512:                rows = cur2.fetchall()
  scripts\reclasificar_turnos_deepseek.py:513:                cur2.close()
  scripts\reclasificar_turnos_deepseek.py:514:                cache[conv_pk] = {int(a): (b or '') for (a, b) in rows}
  scripts\reclasificar_turnos_deepseek.py:515:                return cache[conv_pk]
  scripts\reclasificar_turnos_deepseek.py:516:
  scripts\reclasificar_turnos_deepseek.py:517:            def _detect_role(text: str) -> str:
  scripts\reclasificar_turnos_deepseek.py:518:                t = (text or '').lower()
  scripts\reclasificar_turnos_deepseek.py:519:                if re.search(r"me\s+comunico|de\s+parte\s+de|buen\s+d[ií]a|somos\s+", t):
  scripts\reclasificar_turnos_deepseek.py:520:                    return 'A'  # Agente
  scripts\reclasificar_turnos_deepseek.py:521:                if FILLER_RE.match(t) or re.search(r"si|sí|ok|ya|no|gracias", t):
  scripts\reclasificar_turnos_deepseek.py:522:                    return 'C'  # Cliente probable
  scripts\reclasificar_turnos_deepseek.py:523:                return 'C'
  scripts\reclasificar_turnos_deepseek.py:524:
  scripts\reclasificar_turnos_deepseek.py:525:            def _fmt_with_role(i, label, by_idx):
  scripts\reclasificar_turnos_deepseek.py:526:                t = (by_idx.get(i) or '').replace('\r', ' ').replace('\n', ' ')
  scripts\reclasificar_turnos_deepseek.py:527:                role = _detect_role(t)
  scripts\reclasificar_turnos_deepseek.py:528:                return f"{label} ({role}): {t[:280]}"
  scripts\reclasificar_turnos_deepseek.py:529:
  scripts\reclasificar_turnos_deepseek.py:530:            def _build_context_block_from_cache(conv_pk, turn_idx, cache_by_conv):
  scripts\reclasificar_turnos_deepseek.py:531:                by_idx = _ensure_conv_texts(conn, conv_pk, cache_by_conv)
  scripts\reclasificar_turnos_deepseek.py:532:                block = []
  scripts\reclasificar_turnos_deepseek.py:533:                block.append(_fmt_with_role(turn_idx - 3, 'Turno idx=-3', by_idx))
  scripts\reclasificar_turnos_deepseek.py:534:                block.append(_fmt_with_role(turn_idx - 2, 'Turno idx=-2', by_idx))
  scripts\reclasificar_turnos_deepseek.py:535:                block.append(_fmt_with_role(turn_idx - 1, 'Turno idx=-1', by_idx))
  scripts\reclasificar_turnos_deepseek.py:536:                tgt = (by_idx.get(turn_idx) or '').replace('\r', ' ').replace('\n', ' ')[:280]
  scripts\reclasificar_turnos_deepseek.py:537:                role_tgt = _detect_role(tgt)
  scripts\reclasificar_turnos_deepseek.py:538:                block.append(f"Turno idx=0 (OBJETIVO) ({role_tgt}): {tgt}")
  scripts\reclasificar_turnos_deepseek.py:539:                block.append(_fmt_with_role(turn_idx + 1, 'Turno idx=+1', by_idx))
  scripts\reclasificar_turnos_deepseek.py:540:                return "\n".join(block)
  scripts\reclasificar_turnos_deepseek.py:541:
  scripts\reclasificar_turnos_deepseek.py:542:            context_block = _build_context_block_from_cache(conv_pk, turn_idx, conv_texts_cache)
  scripts\reclasificar_turnos_deepseek.py:543:
  scripts\reclasificar_turnos_deepseek.py:544:            # last_phase info
  scripts\reclasificar_turnos_deepseek.py:545:            cur.execute(
  scripts\reclasificar_turnos_deepseek.py:546:                """
> scripts\reclasificar_turnos_deepseek.py:547:                SELECT fase, fase_conf, fase_source
  scripts\reclasificar_turnos_deepseek.py:548:                FROM sa_turnos
  scripts\reclasificar_turnos_deepseek.py:549:                WHERE conversacion_pk=%s AND turno_idx<%s AND fase IS NOT NULL AND TRIM(fase)<>''
  scripts\reclasificar_turnos_deepseek.py:550:                ORDER BY turno_idx DESC
  scripts\reclasificar_turnos_deepseek.py:551:                LIMIT 1
  scripts\reclasificar_turnos_deepseek.py:552:                """,
  scripts\reclasificar_turnos_deepseek.py:553:                (conv_pk, turn_idx)
  scripts\reclasificar_turnos_deepseek.py:554:            )
  scripts\reclasificar_turnos_deepseek.py:555:            lp_row = cur.fetchone()
  scripts\reclasificar_turnos_deepseek.py:556:            if lp_row:
  scripts\reclasificar_turnos_deepseek.py:557:                last_phase = (lp_row[0] or '').strip()
  scripts\reclasificar_turnos_deepseek.py:558:                last_phase_conf = lp_row[1] if lp_row[1] is not None else ''
  scripts\reclasificar_turnos_deepseek.py:559:                last_phase_source = lp_row[2] or ''
  scripts\reclasificar_turnos_deepseek.py:560:            else:
  scripts\reclasificar_turnos_deepseek.py:561:                last_phase, last_phase_conf, last_phase_source = '', '', ''
  scripts\reclasificar_turnos_deepseek.py:562:            last_phase_info = f"last_phase={last_phase} conf={last_phase_conf} source={last_phase_source}"
  scripts\reclasificar_turnos_deepseek.py:563:
  scripts\reclasificar_turnos_deepseek.py:564:            llm_calls += 1
> scripts\reclasificar_turnos_deepseek.py:565:            res = call_deepseek(
  scripts\reclasificar_turnos_deepseek.py:566:                text=text,
  scripts\reclasificar_turnos_deepseek.py:567:                prev_fase=prev_fase,
  scripts\reclasificar_turnos_deepseek.py:568:                next_fase=next_fase,
  scripts\reclasificar_turnos_deepseek.py:569:                turn_idx=turn_idx,
  scripts\reclasificar_turnos_deepseek.py:570:                total_turns=total_turns,
  scripts\reclasificar_turnos_deepseek.py:571:                base_url=base_url,
  scripts\reclasificar_turnos_deepseek.py:572:                api_key=api_key,
  scripts\reclasificar_turnos_deepseek.py:573:                model=model,
  scripts\reclasificar_turnos_deepseek.py:574:                context_block=context_block,
  scripts\reclasificar_turnos_deepseek.py:575:                last_phase_info=last_phase_info,
  scripts\reclasificar_turnos_deepseek.py:576:                allowed_phases=allowed_list,
  scripts\reclasificar_turnos_deepseek.py:577:            )
  scripts\reclasificar_turnos_deepseek.py:578:
  scripts\reclasificar_turnos_deepseek.py:579:            fase = res["fase"]
  scripts\reclasificar_turnos_deepseek.py:580:            conf = res["conf"]
  scripts\reclasificar_turnos_deepseek.py:581:            is_noise = res.get("is_noise", 0)
  scripts\reclasificar_turnos_deepseek.py:582:            noise_reason = res.get("noise_reason", "")
  scripts\reclasificar_turnos_deepseek.py:583:            rationale = res.get("rationale", "")
  scripts\reclasificar_turnos_deepseek.py:584:
  scripts\reclasificar_turnos_deepseek.py:585:            # Manejo de baja confianza: si conf < 0.40, guardar intento con fallback de contexto
  scripts\reclasificar_turnos_deepseek.py:586:            if int(is_noise) == 1:
  scripts\reclasificar_turnos_deepseek.py:587:                print(f"[NOISE] turno_pk={turno_pk} reason='{noise_reason}' text='{text[:80]}'")
  scripts\reclasificar_turnos_deepseek.py:588:                if do_write:
  scripts\reclasificar_turnos_deepseek.py:589:                    cur.execute(
> scripts\reclasificar_turnos_deepseek.py:590:                        "UPDATE sa_turnos SET fase=NULL, fase_conf=NULL, fase_source=%s WHERE turno_pk=%s AND (fase_source IS NULL OR 
TRIM(fase_source)='' OR fase_source='NO_IMP')",
  scripts\reclasificar_turnos_deepseek.py:591:                        ("NOISE", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:592:                    )
  scripts\reclasificar_turnos_deepseek.py:593:                    if cur.rowcount and cur.rowcount > 0:
  scripts\reclasificar_turnos_deepseek.py:594:                        print(f"[WRITE] turno_pk={turno_pk} old=(fase={fase_db_s if 'fase_db_s' in locals() else 'N/A'},source={source_db if 
'source_db' in locals() else 'N/A'}) new=(fase=NULL,source=NOISE)")
  scripts\reclasificar_turnos_deepseek.py:595:                        noise_written += 1
  scripts\reclasificar_turnos_deepseek.py:596:                        updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:597:                        touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:598:                    else:
  scripts\reclasificar_turnos_deepseek.py:599:                        skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:600:                continue
  scripts\reclasificar_turnos_deepseek.py:601:
  scripts\reclasificar_turnos_deepseek.py:602:            if conf < 0.40 or fase == "NONE":
  scripts\reclasificar_turnos_deepseek.py:603:                # Low confidence: try normalize predicted (fase) to allowed; else mark NOISE
  scripts\reclasificar_turnos_deepseek.py:604:                conf_out = round(max(conf, 0.40), 2)
  scripts\reclasificar_turnos_deepseek.py:605:                norm_low = normalize_fase(fase, text, allowed_set, OLD_PHASES, phase_mapping)
  scripts\reclasificar_turnos_deepseek.py:606:                print(f"[ATTEMPT] turno_pk={turno_pk} conf={conf:.3f} fase={fase} -> norm={norm_low} text='{text[:80]}'")
  scripts\reclasificar_turnos_deepseek.py:607:                if do_write:
  scripts\reclasificar_turnos_deepseek.py:608:                    if norm_low is None:
  scripts\reclasificar_turnos_deepseek.py:609:                        cur.execute(
> scripts\reclasificar_turnos_deepseek.py:610:                            "UPDATE sa_turnos SET fase=NULL, fase_conf=NULL, fase_source=%s WHERE turno_pk=%s AND (fase_source IS NULL OR 
TRIM(fase_source)='' OR fase_source='NO_IMP')",
  scripts\reclasificar_turnos_deepseek.py:611:                            ("NOISE", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:612:                        )
  scripts\reclasificar_turnos_deepseek.py:613:                        if cur.rowcount and cur.rowcount > 0:
  scripts\reclasificar_turnos_deepseek.py:614:                            invalid_phase_mapped_to_noise += 1
  scripts\reclasificar_turnos_deepseek.py:615:                            updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:616:                            touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:617:                        else:
  scripts\reclasificar_turnos_deepseek.py:618:                            skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:619:                    else:
  scripts\reclasificar_turnos_deepseek.py:620:                        if norm_low in OLD_PHASES:
  scripts\reclasificar_turnos_deepseek.py:621:                            wrote_old_phase += 1
  scripts\reclasificar_turnos_deepseek.py:622:                        cur.execute(
> scripts\reclasificar_turnos_deepseek.py:623:                            "UPDATE sa_turnos SET fase=%s, fase_conf=%s, fase_source=%s WHERE turno_pk=%s AND (((fase_source IS NULL OR 
TRIM(fase_source)='') AND (fase IS NULL OR TRIM(fase)='')) OR fase_source='DEEPSEEK_LOW' OR fase_source='NO_IMP')",
> scripts\reclasificar_turnos_deepseek.py:624:                            (norm_low, round(conf_out, 4), "DEEPSEEK_LOW", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:625:                        )
  scripts\reclasificar_turnos_deepseek.py:626:                        if cur.rowcount and cur.rowcount > 0:
> scripts\reclasificar_turnos_deepseek.py:627:                            print(f"[WRITE] turno_pk={turno_pk} old=(fase={fase_db_s if 'fase_db_s' in locals() else 'N/A'},source={source_db if 
'source_db' in locals() else 'N/A'}) new=(fase={norm_low},conf={round(conf_out, 4)},source=DEEPSEEK_LOW)")
  scripts\reclasificar_turnos_deepseek.py:628:                            ok_low += 1
  scripts\reclasificar_turnos_deepseek.py:629:                            updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:630:                            touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:631:                        else:
  scripts\reclasificar_turnos_deepseek.py:632:                            skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:633:                continue
  scripts\reclasificar_turnos_deepseek.py:634:
> scripts\reclasificar_turnos_deepseek.py:635:            # Si no alcanza umbral, escribir como DEEPSEEK_LOW para evitar pendientes infinitos
  scripts\reclasificar_turnos_deepseek.py:636:            if conf < args.conf_threshold:
  scripts\reclasificar_turnos_deepseek.py:637:                norm_low = normalize_fase(fase, text, allowed_set, OLD_PHASES, phase_mapping)
  scripts\reclasificar_turnos_deepseek.py:638:                print(f"[LOW] turno_pk={turno_pk} conf={conf:.3f} fase={fase} -> norm={norm_low} text='{text[:80]}'")
  scripts\reclasificar_turnos_deepseek.py:639:                if do_write:
  scripts\reclasificar_turnos_deepseek.py:640:                    if norm_low is None:
  scripts\reclasificar_turnos_deepseek.py:641:                        cur.execute(
> scripts\reclasificar_turnos_deepseek.py:642:                            "UPDATE sa_turnos SET fase=NULL, fase_conf=NULL, fase_source=%s WHERE turno_pk=%s AND (fase_source IS NULL OR 
TRIM(fase_source)='' OR fase_source='NO_IMP')",
  scripts\reclasificar_turnos_deepseek.py:643:                            ("NOISE", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:644:                        )
  scripts\reclasificar_turnos_deepseek.py:645:                        if cur.rowcount and cur.rowcount > 0:
  scripts\reclasificar_turnos_deepseek.py:646:                            print(f"[WRITE] turno_pk={turno_pk} old=(fase={fase_db_s if 'fase_db_s' in locals() else 'N/A'},source={source_db if 
'source_db' in locals() else 'N/A'}) new=(fase=NULL,source=NOISE)")
  scripts\reclasificar_turnos_deepseek.py:647:                            invalid_phase_mapped_to_noise += 1
  scripts\reclasificar_turnos_deepseek.py:648:                            updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:649:                            touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:650:                        else:
  scripts\reclasificar_turnos_deepseek.py:651:                            skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:652:                    else:
  scripts\reclasificar_turnos_deepseek.py:653:                        if norm_low in OLD_PHASES:
  scripts\reclasificar_turnos_deepseek.py:654:                            wrote_old_phase += 1
  scripts\reclasificar_turnos_deepseek.py:655:                        cur.execute(
> scripts\reclasificar_turnos_deepseek.py:656:                            "UPDATE sa_turnos SET fase=%s, fase_conf=%s, fase_source=%s WHERE turno_pk=%s AND (((fase_source IS NULL OR 
TRIM(fase_source)='') AND (fase IS NULL OR TRIM(fase)='')) OR fase_source='DEEPSEEK_LOW' OR fase_source='NO_IMP')",
> scripts\reclasificar_turnos_deepseek.py:657:                            (norm_low, round(conf, 4), "DEEPSEEK_LOW", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:658:                        )
  scripts\reclasificar_turnos_deepseek.py:659:                        if cur.rowcount and cur.rowcount > 0:
> scripts\reclasificar_turnos_deepseek.py:660:                            print(f"[WRITE] turno_pk={turno_pk} old=(fase={fase_db_s if 'fase_db_s' in locals() else 'N/A'},source={source_db if 
'source_db' in locals() else 'N/A'}) new=(fase={norm_low},conf={round(conf, 4)},source=DEEPSEEK_LOW)")
  scripts\reclasificar_turnos_deepseek.py:661:                            ok_low += 1
  scripts\reclasificar_turnos_deepseek.py:662:                            updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:663:                            touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:664:                        else:
  scripts\reclasificar_turnos_deepseek.py:665:                            skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:666:                continue
  scripts\reclasificar_turnos_deepseek.py:667:
  scripts\reclasificar_turnos_deepseek.py:668:            # Guardrails post-LLM
  scripts\reclasificar_turnos_deepseek.py:669:            by_idx = conv_texts_cache.get(conv_pk, {})
  scripts\reclasificar_turnos_deepseek.py:670:            prev_texts = [by_idx.get(turn_idx - k, '') for k in [1,2,3]]
  scripts\reclasificar_turnos_deepseek.py:671:            next_text = by_idx.get(turn_idx + 1, '')
  scripts\reclasificar_turnos_deepseek.py:672:            has_next_meaningful = bool(next_text and len(next_text.strip())>0 and not FILLER_RE.match(next_text.strip().lower()))
  scripts\reclasificar_turnos_deepseek.py:673:            final_fase, final_conf, _final_source_unused, reason = apply_guardrails(
  scripts\reclasificar_turnos_deepseek.py:674:                fase, conf, 0, last_phase, has_next_meaningful, text, prev_texts
  scripts\reclasificar_turnos_deepseek.py:675:            )
  scripts\reclasificar_turnos_deepseek.py:676:            if final_fase != fase:
  scripts\reclasificar_turnos_deepseek.py:677:                print(f"[GUARD] turno_pk={turno_pk} pred={fase}/{conf:.2f} -> final={final_fase}/{final_conf:.2f} reason={reason}")
  scripts\reclasificar_turnos_deepseek.py:678:            else:
  scripts\reclasificar_turnos_deepseek.py:679:                print(f"[OK] turno_pk={turno_pk} -> fase={fase} conf={conf:.3f} prev={prev_fase} next={next_fase} text='{text[:80]}' 
rationale='{rationale[:60]}'")
  scripts\reclasificar_turnos_deepseek.py:680:            # Normalize final_fase to allowed
  scripts\reclasificar_turnos_deepseek.py:681:            norm_final = normalize_fase(final_fase, text, allowed_set, OLD_PHASES, phase_mapping)
  scripts\reclasificar_turnos_deepseek.py:682:            if norm_final is None:
  scripts\reclasificar_turnos_deepseek.py:683:                print(f"[FINAL->NOISE] turno_pk={turno_pk} final={final_fase} not allowed -> NOISE")
  scripts\reclasificar_turnos_deepseek.py:684:                if do_write:
  scripts\reclasificar_turnos_deepseek.py:685:                    cur.execute(
> scripts\reclasificar_turnos_deepseek.py:686:                        "UPDATE sa_turnos SET fase=NULL, fase_conf=NULL, fase_source=%s WHERE turno_pk=%s AND (fase_source IS NULL OR 
TRIM(fase_source)='' OR fase_source='NO_IMP')",
  scripts\reclasificar_turnos_deepseek.py:687:                        ("NOISE", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:688:                    )
  scripts\reclasificar_turnos_deepseek.py:689:                    if cur.rowcount and cur.rowcount > 0:
  scripts\reclasificar_turnos_deepseek.py:690:                        print(f"[WRITE] turno_pk={turno_pk} old=(fase={fase_db_s if 'fase_db_s' in locals() else 'N/A'},source={source_db if 
'source_db' in locals() else 'N/A'}) new=(fase=NULL,source=NOISE)")
  scripts\reclasificar_turnos_deepseek.py:691:                        invalid_phase_mapped_to_noise += 1
  scripts\reclasificar_turnos_deepseek.py:692:                        updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:693:                        touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:694:                    else:
  scripts\reclasificar_turnos_deepseek.py:695:                        skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:696:            else:
  scripts\reclasificar_turnos_deepseek.py:697:                if do_write:
  scripts\reclasificar_turnos_deepseek.py:698:                    if norm_final in OLD_PHASES:
  scripts\reclasificar_turnos_deepseek.py:699:                        wrote_old_phase += 1
  scripts\reclasificar_turnos_deepseek.py:700:                    # Mapeo adicional: INFORMACION_DEUDA -> EXPOSICION_DEUDA
  scripts\reclasificar_turnos_deepseek.py:701:                    final_to_write = norm_final
  scripts\reclasificar_turnos_deepseek.py:702:                    if norm_final == 'INFORMACION_DEUDA':
  scripts\reclasificar_turnos_deepseek.py:703:                        final_to_write = 'EXPOSICION_DEUDA'
  scripts\reclasificar_turnos_deepseek.py:704:                        print(f"[MAP] turno_pk={turno_pk} INFORMACION_DEUDA -> EXPOSICION_DEUDA")
> scripts\reclasificar_turnos_deepseek.py:705:                    # Source: DEEPSEEK (high) per spec; keep threshold already passed
  scripts\reclasificar_turnos_deepseek.py:706:                    cur.execute(
> scripts\reclasificar_turnos_deepseek.py:707:                        "UPDATE sa_turnos SET fase=%s, fase_conf=%s, fase_source=%s WHERE turno_pk=%s AND (((fase_source IS NULL OR 
TRIM(fase_source)='') AND (fase IS NULL OR TRIM(fase)='')) OR fase_source='DEEPSEEK_LOW' OR fase_source='NO_IMP')",
> scripts\reclasificar_turnos_deepseek.py:708:                        (final_to_write, round(final_conf, 4), "DEEPSEEK", turno_pk),
  scripts\reclasificar_turnos_deepseek.py:709:                    )
  scripts\reclasificar_turnos_deepseek.py:710:                    if cur.rowcount and cur.rowcount > 0:
> scripts\reclasificar_turnos_deepseek.py:711:                        print(f"[WRITE] turno_pk={turno_pk} old=(fase={fase_db_s if 'fase_db_s' in locals() else 'N/A'},conf={conf_db if 
'conf_db' in locals() else 'N/A'},source={source_db if 'source_db' in locals() else 'N/A'}) new=(fase={final_to_write},conf={round(final_conf, 4)},source=DEEPSEEK)")
  scripts\reclasificar_turnos_deepseek.py:712:                        updated_turnos += 1
  scripts\reclasificar_turnos_deepseek.py:713:                        ok_high += 1
  scripts\reclasificar_turnos_deepseek.py:714:                        touched_convs.add(conv_pk)
  scripts\reclasificar_turnos_deepseek.py:715:                    else:
  scripts\reclasificar_turnos_deepseek.py:716:                        skipped_existing += 1
  scripts\reclasificar_turnos_deepseek.py:717:
  scripts\reclasificar_turnos_deepseek.py:718:            time.sleep(0.10)  # micro-rate-limit
  scripts\reclasificar_turnos_deepseek.py:719:
  scripts\reclasificar_turnos_deepseek.py:720:    if do_write and updated_turnos:
  scripts\reclasificar_turnos_deepseek.py:721:        # recalcular estado final de conversación y marcar llm_usado=1
  scripts\reclasificar_turnos_deepseek.py:722:        update_conversation_final_fields(cur, touched_convs)
  scripts\reclasificar_turnos_deepseek.py:723:        conn.commit()
  scripts\reclasificar_turnos_deepseek.py:724:
  scripts\reclasificar_turnos_deepseek.py:725:    cur.close()
  scripts\reclasificar_turnos_deepseek.py:726:    conn.close()
  scripts\reclasificar_turnos_deepseek.py:727:
  scripts\reclasificar_turnos_deepseek.py:728:    print(f"\nDONE write={args.write} dry_run={args.dry_run} do_write={do_write} updated_turnos={updated_turnos} 
touched_convs={len(touched_convs)} base_url={base_url} model={model}")
  scripts\reclasificar_turnos_deepseek.py:729:    print(f"Summary: selected_rows={selected_rows} llm_calls={llm_calls} ok_high={ok_high} ok_low={ok_low} heuristic_written={heuristic_written} 
no_text_written={no_text_written} noise_written={noise_written} skipped_existing={skipped_existing} skipped_non_pending={skipped_non_pending}")
  scripts\reclasificar_turnos_deepseek.py:730:
  scripts\reclasificar_turnos_deepseek.py:731:if __name__ == "__main__":
  scripts\reclasificar_turnos_deepseek.py:732:    main()
> scripts\sa_cli.py:39:    pipe_parser = subparsers.add_parser('pipeline-fases', help='Pipeline completo: RULES -> export pendientes -> (opcional) DeepSeek -> recalc resumen.')
  scripts\sa_cli.py:40:    pipe_parser.add_argument('--ejecucion_id', required=True, type=int, help='ID de la ejecución a procesar.')
  scripts\sa_cli.py:41:    pipe_parser.add_argument('--limit', type=int, default=0, help='Limitar conversaciones para RULES (0 = todas).')
  scripts\sa_cli.py:42:    pipe_parser.add_argument('--conf_threshold', type=float, default=0.55, help='Umbral de confianza para RULES y filtro de pendientes.')
> scripts\sa_cli.py:43:    pipe_parser.add_argument('--deepseek', action='store_true', help='Si se establece, reclasifica pendientes con DeepSeek.')
> scripts\sa_cli.py:44:    pipe_parser.add_argument('--max_rows', type=int, default=0, help='Máximo de filas a procesar en DeepSeek (0 = sin límite).')
> scripts\sa_cli.py:45:    pipe_parser.add_argument('--write', action='store_true', help='Si se establece junto a pipeline DeepSeek, escribe en DB.')
> scripts\sa_cli.py:46:    pipe_parser.add_argument('--dry_run', action='store_true', help='Dry-run para DeepSeek (no escribe).')
  scripts\sa_cli.py:47:    pipe_parser.add_argument('--mapeo_version', default='v1.0', help='Versión del mapeo fase_mapeo_oficial (ej: v12a8_ej2_2026-02-09).')
  scripts\sa_cli.py:48:    pipe_parser.add_argument('--postprocess', action='store_true', default=True, help='Ejecutar postprocesado al final (default: True).')
  scripts\sa_cli.py:49:    pipe_parser.add_argument('--no-postprocess', dest='postprocess', action='store_false', help='NO ejecutar postprocesado al final.')
  scripts\sa_cli.py:50:    pipe_parser.add_argument('--verbose', action='store_true', help='Logs detallados durante el pipeline.')
  scripts\sa_cli.py:51:
  scripts\sa_cli.py:52:    # Comando export-pendientes-llm
  scripts\sa_cli.py:53:    export_parser = subparsers.add_parser('export-pendientes-llm', help='Exporta pendientes LLM a CSV para una ejecución.')
  scripts\sa_cli.py:54:    export_parser.add_argument('--ejecucion_id', required=True, type=int, help='ID de la ejecución a exportar.')
  scripts\sa_cli.py:55:    export_parser.add_argument('--conf_threshold', type=float, default=0.55, help='Umbral de confianza para filtrar pendientes.')
  scripts\sa_cli.py:56:    export_parser.add_argument('--limit', type=int, default=0, help='Limitar el número de filas exportadas (0 = sin límite).')
  scripts\sa_cli.py:57:    export_parser.add_argument('--out_dir', default='out_reports', help='Directorio de salida para el CSV.')
  scripts\sa_cli.py:58:
  scripts\sa_cli.py:59:    # Comando smooth-fases
  scripts\sa_cli.py:60:    smooth_parser = subparsers.add_parser('smooth-fases', help='Suaviza fases por secuencia para reducir transiciones ilegales.')
  scripts\sa_cli.py:61:    smooth_parser.add_argument('--ejecucion_id', required=True, type=int, help='ID de la ejecución a procesar.')
  scripts\sa_cli.py:62:    smooth_parser.add_argument('--conf_min', type=float, default=0.40, help='Confianza mínima para considerar cambio (preferir menor conf).')
  scripts\sa_cli.py:63:    smooth_parser.add_argument('--write', action='store_true', help='Si se establece, aplica cambios en DB.')
  scripts\sa_cli.py:64:    smooth_parser.add_argument('--verbose', action='store_true', help='Mostrar logs detallados durante el suavizado.')
  scripts\sa_cli.py:65:
  scripts\sa_cli.py:66:    args = parser.parse_args()
  scripts\sa_cli.py:67:
  scripts\sa_cli.py:68:    try:
  scripts\sa_cli.py:69:        config = load_config()
  scripts\sa_cli.py:70:    except FileNotFoundError as e:
  scripts\sa_cli.py:71:        print(e)
  scripts\sa_cli.py:72:        print("Por favor, cree un archivo 'config.ini' a partir de 'config.ini.example'.")
  scripts\sa_cli.py:73:        sys.exit(1)
  scripts\sa_cli.py:74:
  scripts\sa_cli.py:75:    conn = get_conn(config)
  scripts\sa_cli.py:76:    if not conn:
  scripts\sa_cli.py:77:        sys.exit(1)
  scripts\sa_cli.py:78:
  scripts\sa_cli.py:79:    try:
  scripts\sa_cli.py:80:        # Asegurar que el esquema de la BD exista
  scripts\sa_cli.py:81:        print("Asegurando que el esquema de la base de datos esté actualizado...")
  scripts\sa_cli.py:82:        ensure_schema(conn)
  scripts\sa_cli.py:83:        print("Esquema OK.")
  scripts\sa_cli.py:84:
  scripts\sa_cli.py:85:        if args.command == 'ingest':
  scripts\sa_cli.py:86:            if not os.path.isdir(args.input_dir):
  scripts\sa_cli.py:87:                print(f"Error: El directorio de entrada '{args.input_dir}' no existe.")
  scripts\sa_cli.py:88:                sys.exit(1)
  scripts\sa_cli.py:89:            
  scripts\sa_cli.py:90:            ingest_dir(conn, args.input_dir, args.notas)
  scripts\sa_cli.py:91:        
  scripts\sa_cli.py:92:        elif args.command == 'parse-turns':
  scripts\sa_cli.py:93:            parse_turns_for_run(conn, args.ejecucion_id, args.limit, args.verbose)
  scripts\sa_cli.py:94:
  scripts\sa_cli.py:95:        elif args.command == 'detect-fases':
  scripts\sa_cli.py:96:            apply_fase_rules_for_run(
  scripts\sa_cli.py:97:                conn,
  scripts\sa_cli.py:98:                ejecucion_id=args.ejecucion_id,
  scripts\sa_cli.py:99:                limit=args.limit,
  scripts\sa_cli.py:100:                conf_threshold=args.conf_threshold,
  scripts\sa_cli.py:101:                verbose=args.verbose,
  scripts\sa_cli.py:102:            )
  scripts\sa_cli.py:103:
  scripts\sa_cli.py:104:        elif args.command == 'pipeline-fases':
  scripts\sa_cli.py:105:            # 1) RULES
  scripts\sa_cli.py:106:            apply_fase_rules_for_run(
  scripts\sa_cli.py:107:                conn,
  scripts\sa_cli.py:108:                ejecucion_id=args.ejecucion_id,
  scripts\sa_cli.py:109:                limit=args.limit,
  scripts\sa_cli.py:110:                conf_threshold=args.conf_threshold,
  scripts\sa_cli.py:111:                verbose=args.verbose,
  scripts\sa_cli.py:112:            )
  scripts\sa_cli.py:113:
  scripts\sa_cli.py:114:            # 2) Exportar pendientes
  scripts\sa_cli.py:115:            res_export = export_pendientes_llm(conn, args.ejecucion_id, args.conf_threshold)
  scripts\sa_cli.py:116:            csv_path = res_export.get('path')
  scripts\sa_cli.py:117:            null_before = int(res_export.get('rows', 0))
  scripts\sa_cli.py:118:            if args.verbose:
  scripts\sa_cli.py:119:                print(f"Exportado pendientes a: {csv_path} ({null_before} filas)")
  scripts\sa_cli.py:120:
> scripts\sa_cli.py:121:            deepseek_updates = 0
  scripts\sa_cli.py:122:            convs_llm_usado = 0
  scripts\sa_cli.py:123:
> scripts\sa_cli.py:124:            # 3) Opcional: DeepSeek usando reclasificar_turnos_deepseek.py
> scripts\sa_cli.py:125:            if args.deepseek:
  scripts\sa_cli.py:126:                if args.verbose:
> scripts\sa_cli.py:127:                    print("\n--- Ejecutando reclasificar_turnos_deepseek (from_db) ---")
  scripts\sa_cli.py:128:                
> scripts\sa_cli.py:129:                # Ejecutar reclasificar_turnos_deepseek usando subprocess para reutilizar su lógica completa
  scripts\sa_cli.py:130:                import subprocess
  scripts\sa_cli.py:131:                cmd = [
> scripts\sa_cli.py:132:                    sys.executable, "-m", "scripts.reclasificar_turnos_deepseek",
  scripts\sa_cli.py:133:                    "--ejecucion_id", str(args.ejecucion_id),
  scripts\sa_cli.py:134:                    "--from_db",
  scripts\sa_cli.py:135:                    "--config", "config.ini",
  scripts\sa_cli.py:136:                    "--conf_threshold", str(args.conf_threshold),
  scripts\sa_cli.py:137:                    "--mapeo_version", args.mapeo_version,
  scripts\sa_cli.py:138:                ]
  scripts\sa_cli.py:139:                if args.max_rows and args.max_rows > 0:
  scripts\sa_cli.py:140:                    cmd.extend(["--max_rows", str(args.max_rows)])
  scripts\sa_cli.py:141:                if args.write and not args.dry_run:
  scripts\sa_cli.py:142:                    cmd.append("--write")
  scripts\sa_cli.py:143:                if args.dry_run:
  scripts\sa_cli.py:144:                    cmd.append("--dry_run")
  scripts\sa_cli.py:145:                
  scripts\sa_cli.py:146:                result = subprocess.run(cmd, capture_output=False)
  scripts\sa_cli.py:147:                if result.returncode != 0:
> scripts\sa_cli.py:148:                    print(f"ERROR: reclasificar_turnos_deepseek falló con código {result.returncode}")
  scripts\sa_cli.py:149:                
> scripts\sa_cli.py:150:                # Conteo post-DeepSeek
  scripts\sa_cli.py:151:                cur = conn.cursor()
  scripts\sa_cli.py:152:                cur.execute(
  scripts\sa_cli.py:153:                    "SELECT COUNT(*) FROM sa_conversaciones WHERE ejecucion_id=%s AND llm_usado=1",
  scripts\sa_cli.py:154:                    (args.ejecucion_id,)
  scripts\sa_cli.py:155:                )
  scripts\sa_cli.py:156:                convs_llm_usado = int(cur.fetchone()[0])
  scripts\sa_cli.py:157:                cur.close()
  scripts\sa_cli.py:158:
  scripts\sa_cli.py:159:            # 4) Postprocesado
  scripts\sa_cli.py:160:            postprocess_executed = False
  scripts\sa_cli.py:161:            if args.postprocess:
  scripts\sa_cli.py:162:                if args.verbose:
  scripts\sa_cli.py:163:                    print("\n--- Ejecutando postprocess_ejecucion.py ---")
  scripts\sa_cli.py:164:                
  scripts\sa_cli.py:165:                import subprocess
  scripts\sa_cli.py:166:                do_write_postprocess = bool(args.write) and (not args.dry_run)
  scripts\sa_cli.py:167:                cmd_post = [
  scripts\sa_cli.py:168:                    sys.executable, "-m", "scripts.postprocess_ejecucion",
  scripts\sa_cli.py:169:                    "--ejecucion_id", str(args.ejecucion_id),
  scripts\sa_cli.py:170:                    "--mapeo_version", args.mapeo_version,
  scripts\sa_cli.py:171:                    "--config", "config.ini",
  scripts\sa_cli.py:172:                ]
  scripts\sa_cli.py:173:                if do_write_postprocess:
  scripts\sa_cli.py:174:                    cmd_post.append("--write")
  scripts\sa_cli.py:175:                if args.verbose:
  scripts\sa_cli.py:176:                    cmd_post.append("--verbose")
  scripts\sa_cli.py:177:                
  scripts\sa_cli.py:178:                result_post = subprocess.run(cmd_post, capture_output=False)
  scripts\sa_cli.py:179:                if result_post.returncode == 0:
  scripts\sa_cli.py:180:                    postprocess_executed = True
  scripts\sa_cli.py:181:                else:
  scripts\sa_cli.py:182:                    print(f"WARNING: postprocess_ejecucion falló con código {result_post.returncode}")
  scripts\sa_cli.py:183:
  scripts\sa_cli.py:184:            # 5) Resumen final
  scripts\sa_cli.py:185:            cur = conn.cursor()
  scripts\sa_cli.py:186:            
  scripts\sa_cli.py:187:            # Total turnos
  scripts\sa_cli.py:188:            cur.execute(
  scripts\sa_cli.py:189:                "SELECT COUNT(*) FROM sa_turnos t JOIN sa_conversaciones c ON t.conversacion_pk=c.conversacion_pk WHERE c.ejecucion_id=%s",
  scripts\sa_cli.py:190:                (args.ejecucion_id,)
  scripts\sa_cli.py:191:            )
  scripts\sa_cli.py:192:            total_turnos = int(cur.fetchone()[0])
  scripts\sa_cli.py:193:
> scripts\sa_cli.py:194:            # Turnos clasificados por DeepSeek
  scripts\sa_cli.py:195:            cur.execute(
  scripts\sa_cli.py:196:                """
  scripts\sa_cli.py:197:                SELECT COUNT(*)
  scripts\sa_cli.py:198:                FROM sa_turnos t
  scripts\sa_cli.py:199:                JOIN sa_conversaciones c ON t.conversacion_pk=c.conversacion_pk
> scripts\sa_cli.py:200:                WHERE c.ejecucion_id=%s AND t.fase_source='DEEPSEEK'
  scripts\sa_cli.py:201:                """,
  scripts\sa_cli.py:202:                (args.ejecucion_id,)
  scripts\sa_cli.py:203:            )
> scripts\sa_cli.py:204:            deepseek_turnos = int(cur.fetchone()[0])
  scripts\sa_cli.py:205:
  scripts\sa_cli.py:206:            # Turnos marcados como NOISE
  scripts\sa_cli.py:207:            cur.execute(
  scripts\sa_cli.py:208:                """
  scripts\sa_cli.py:209:                SELECT COUNT(*)
  scripts\sa_cli.py:210:                FROM sa_turnos t
  scripts\sa_cli.py:211:                JOIN sa_conversaciones c ON t.conversacion_pk=c.conversacion_pk
  scripts\sa_cli.py:212:                WHERE c.ejecucion_id=%s AND t.fase_source='NOISE'
  scripts\sa_cli.py:213:                """,
  scripts\sa_cli.py:214:                (args.ejecucion_id,)
  scripts\sa_cli.py:215:            )
  scripts\sa_cli.py:216:            noise_turnos = int(cur.fetchone()[0])
  scripts\sa_cli.py:217:
  scripts\sa_cli.py:218:            # Turnos con fase NULL o vacía
  scripts\sa_cli.py:219:            cur.execute(
  scripts\sa_cli.py:220:                """
  scripts\sa_cli.py:221:                SELECT COUNT(*)
  scripts\sa_cli.py:222:                FROM sa_turnos t
  scripts\sa_cli.py:223:                JOIN sa_conversaciones c ON t.conversacion_pk=c.conversacion_pk
> scripts\sa_cli.py:224:                WHERE c.ejecucion_id=%s AND (t.fase IS NULL OR TRIM(t.fase)='')
  scripts\sa_cli.py:225:                """,
  scripts\sa_cli.py:226:                (args.ejecucion_id,)
  scripts\sa_cli.py:227:            )
  scripts\sa_cli.py:228:            fase_null_total = int(cur.fetchone()[0])
  scripts\sa_cli.py:229:
  scripts\sa_cli.py:230:            # Pendientes después (sin filtrar por fase_source)
  scripts\sa_cli.py:231:            cur.execute(
  scripts\sa_cli.py:232:                """
  scripts\sa_cli.py:233:                SELECT COUNT(*)
  scripts\sa_cli.py:234:                FROM sa_turnos t
  scripts\sa_cli.py:235:                JOIN sa_conversaciones c ON t.conversacion_pk=c.conversacion_pk
  scripts\sa_cli.py:236:                WHERE c.ejecucion_id=%s
> scripts\sa_cli.py:237:                  AND (t.fase IS NULL OR TRIM(t.fase)='' OR t.fase_conf IS NULL OR t.fase_conf < %s)
  scripts\sa_cli.py:238:                """,
  scripts\sa_cli.py:239:                (args.ejecucion_id, args.conf_threshold)
  scripts\sa_cli.py:240:            )
  scripts\sa_cli.py:241:            pendientes_after = int(cur.fetchone()[0])
  scripts\sa_cli.py:242:            
  scripts\sa_cli.py:243:            cur.close()
  scripts\sa_cli.py:244:
  scripts\sa_cli.py:245:            print("\n--- Resumen Pipeline Fases ---")
  scripts\sa_cli.py:246:            print(f"Ejecución: {args.ejecucion_id}")
  scripts\sa_cli.py:247:            print(f"Total turnos: {total_turnos}")
  scripts\sa_cli.py:248:            print(f"Pendientes antes: {null_before}")
  scripts\sa_cli.py:249:            print(f"Pendientes después: {pendientes_after}")
> scripts\sa_cli.py:250:            print(f"Turnos DEEPSEEK: {deepseek_turnos}")
  scripts\sa_cli.py:251:            print(f"Turnos NOISE: {noise_turnos}")
  scripts\sa_cli.py:252:            print(f"Fase NULL/vacía: {fase_null_total}")
  scripts\sa_cli.py:253:            print(f"Convs llm_usado=1: {convs_llm_usado}")
  scripts\sa_cli.py:254:            print(f"Postprocess ejecutado: {'SI' if postprocess_executed else 'NO'}")
  scripts\sa_cli.py:255:            print(f"mapeo_version usado: {args.mapeo_version}")
  scripts\sa_cli.py:256:
  scripts\sa_cli.py:257:        elif args.command == 'export-pendientes-llm':
  scripts\sa_cli.py:258:            export_pendientes_llm(
  scripts\sa_cli.py:259:                conn,
  scripts\sa_cli.py:260:                ejecucion_id=args.ejecucion_id,
  scripts\sa_cli.py:261:                conf_threshold=args.conf_threshold,
  scripts\sa_cli.py:262:                limit=args.limit,
  scripts\sa_cli.py:263:                out_dir=args.out_dir,
  scripts\sa_cli.py:264:            )
  scripts\sa_cli.py:265:
  scripts\sa_cli.py:266:        elif args.command == 'smooth-fases':
  scripts\sa_cli.py:267:            suavizar_fases_por_secuencia(
  scripts\sa_cli.py:268:                conn,
  scripts\sa_cli.py:269:                ejecucion_id=args.ejecucion_id,
  scripts\sa_cli.py:270:                conf_min=args.conf_min,
  scripts\sa_cli.py:271:                write=args.write,
  scripts\sa_cli.py:272:                verbose=args.verbose,
  scripts\sa_cli.py:273:            )
  scripts\sa_cli.py:274:
  scripts\sa_cli.py:275:
  scripts\sa_cli.py:276:    finally:
  scripts\sa_cli.py:277:        if conn and conn.is_connected():
  scripts\sa_cli.py:278:            conn.close()
  scripts\sa_cli.py:279:            print("Conexión a la base de datos cerrada.")
  scripts\sa_cli.py:280:
  scripts\sa_cli.py:281:if __name__ == '__main__':
  scripts\sa_cli.py:282:    main()
> scripts\suavizar_fases_por_secuencia.py:52:            SELECT turno_pk, turno_idx, fase, fase_conf, fase_source, text
  scripts\suavizar_fases_por_secuencia.py:53:            FROM sa_turnos
  scripts\suavizar_fases_por_secuencia.py:54:            WHERE conversacion_pk=%s
  scripts\suavizar_fases_por_secuencia.py:55:            ORDER BY turno_idx
  scripts\suavizar_fases_por_secuencia.py:56:            """,
  scripts\suavizar_fases_por_secuencia.py:57:            (conv_pk,)
  scripts\suavizar_fases_por_secuencia.py:58:        )
  scripts\suavizar_fases_por_secuencia.py:59:        rows = cur.fetchall()
  scripts\suavizar_fases_por_secuencia.py:60:        if not rows:
  scripts\suavizar_fases_por_secuencia.py:61:            continue
  scripts\suavizar_fases_por_secuencia.py:62:
  scripts\suavizar_fases_por_secuencia.py:63:        # Local copies to simulate changes before writing
  scripts\suavizar_fases_por_secuencia.py:64:        local = [
  scripts\suavizar_fases_por_secuencia.py:65:            {
  scripts\suavizar_fases_por_secuencia.py:66:                "turno_pk": int(r[0]),
  scripts\suavizar_fases_por_secuencia.py:67:                "turno_idx": int(r[1]),
  scripts\suavizar_fases_por_secuencia.py:68:                "fase": (r[2] or "").strip().upper(),
> scripts\suavizar_fases_por_secuencia.py:69:                "fase_conf": float(r[3]) if r[3] is not None else None,
  scripts\suavizar_fases_por_secuencia.py:70:                "fase_source": (r[4] or ""),
  scripts\suavizar_fases_por_secuencia.py:71:                "text": (r[5] or ""),
  scripts\suavizar_fases_por_secuencia.py:72:            }
  scripts\suavizar_fases_por_secuencia.py:73:            for r in rows
  scripts\suavizar_fases_por_secuencia.py:74:        ]
  scripts\suavizar_fases_por_secuencia.py:75:
  scripts\suavizar_fases_por_secuencia.py:76:        # Count violations before
  scripts\suavizar_fases_por_secuencia.py:77:        violations = 0
  scripts\suavizar_fases_por_secuencia.py:78:        for i in range(len(local) - 1):
  scripts\suavizar_fases_por_secuencia.py:79:            a = local[i]["fase"]
  scripts\suavizar_fases_por_secuencia.py:80:            b = local[i + 1]["fase"]
  scripts\suavizar_fases_por_secuencia.py:81:            if a and b and not is_allowed(a, b):
  scripts\suavizar_fases_por_secuencia.py:82:                violations += 1
  scripts\suavizar_fases_por_secuencia.py:83:        total_violations_before += violations
  scripts\suavizar_fases_por_secuencia.py:84:
  scripts\suavizar_fases_por_secuencia.py:85:        # Smooth pass
  scripts\suavizar_fases_por_secuencia.py:86:        for i in range(len(local) - 1):
  scripts\suavizar_fases_por_secuencia.py:87:            a = local[i]["fase"]
  scripts\suavizar_fases_por_secuencia.py:88:            b = local[i + 1]["fase"]
  scripts\suavizar_fases_por_secuencia.py:89:            if not a or not b:
  scripts\suavizar_fases_por_secuencia.py:90:                continue
  scripts\suavizar_fases_por_secuencia.py:91:            if is_allowed(a, b):
  scripts\suavizar_fases_por_secuencia.py:92:                continue
  scripts\suavizar_fases_por_secuencia.py:93:
> scripts\suavizar_fases_por_secuencia.py:94:            # Protection: don't touch strong DeepSeek
> scripts\suavizar_fases_por_secuencia.py:95:            prot_a = (local[i]["fase_source"] == "DEEPSEEK" and (local[i]["fase_conf"] or 0) >= 0.70)
> scripts\suavizar_fases_por_secuencia.py:96:            prot_b = (local[i + 1]["fase_source"] == "DEEPSEEK" and (local[i + 1]["fase_conf"] or 0) >= 0.70)
  scripts\suavizar_fases_por_secuencia.py:97:
> scripts\suavizar_fases_por_secuencia.py:98:            conf_a = (local[i]["fase_conf"] or 0.0)
> scripts\suavizar_fases_por_secuencia.py:99:            conf_b = (local[i + 1]["fase_conf"] or 0.0)
  scripts\suavizar_fases_por_secuencia.py:100:
  scripts\suavizar_fases_por_secuencia.py:101:            new_phase = None
  scripts\suavizar_fases_por_secuencia.py:102:            target_idx = None
  scripts\suavizar_fases_por_secuencia.py:103:
  scripts\suavizar_fases_por_secuencia.py:104:            # Prefer modify the lower confidence turn
  scripts\suavizar_fases_por_secuencia.py:105:            if (not prot_b) and (conf_b < conf_a or conf_b < conf_min):
  scripts\suavizar_fases_por_secuencia.py:106:                # change B to A
  scripts\suavizar_fases_por_secuencia.py:107:                new_phase = a
  scripts\suavizar_fases_por_secuencia.py:108:                target_idx = i + 1
  scripts\suavizar_fases_por_secuencia.py:109:            elif (not prot_a) and (conf_a < conf_min):
  scripts\suavizar_fases_por_secuencia.py:110:                # change A to B
  scripts\suavizar_fases_por_secuencia.py:111:                new_phase = b
  scripts\suavizar_fases_por_secuencia.py:112:                target_idx = i
  scripts\suavizar_fases_por_secuencia.py:113:            else:
  scripts\suavizar_fases_por_secuencia.py:114:                mid = _intermediate_for(a, b)
  scripts\suavizar_fases_por_secuencia.py:115:                if mid:
  scripts\suavizar_fases_por_secuencia.py:116:                    if not prot_b and (conf_b <= conf_a):
  scripts\suavizar_fases_por_secuencia.py:117:                        new_phase = mid
  scripts\suavizar_fases_por_secuencia.py:118:                        target_idx = i + 1
  scripts\suavizar_fases_por_secuencia.py:119:                    elif not prot_a:
  scripts\suavizar_fases_por_secuencia.py:120:                        new_phase = mid
  scripts\suavizar_fases_por_secuencia.py:121:                        target_idx = i
  scripts\suavizar_fases_por_secuencia.py:122:
  scripts\suavizar_fases_por_secuencia.py:123:            if new_phase and target_idx is not None:
  scripts\suavizar_fases_por_secuencia.py:124:                old_phase = local[target_idx]["fase"]
  scripts\suavizar_fases_por_secuencia.py:125:                if old_phase == new_phase:
  scripts\suavizar_fases_por_secuencia.py:126:                    continue
  scripts\suavizar_fases_por_secuencia.py:127:                local[target_idx]["fase"] = new_phase
> scripts\suavizar_fases_por_secuencia.py:128:                local[target_idx]["fase_conf"] = 0.55  # set to standard smoothed confidence
  scripts\suavizar_fases_por_secuencia.py:129:                local[target_idx]["fase_source"] = "SMOOTH"
  scripts\suavizar_fases_por_secuencia.py:130:                total_changes += 1
  scripts\suavizar_fases_por_secuencia.py:131:                changes_log.append((conv_pk, local[target_idx]["turno_pk"], old_phase, new_phase))
  scripts\suavizar_fases_por_secuencia.py:132:
  scripts\suavizar_fases_por_secuencia.py:133:        # Count violations after
  scripts\suavizar_fases_por_secuencia.py:134:        violations_after = 0
  scripts\suavizar_fases_por_secuencia.py:135:        for i in range(len(local) - 1):
  scripts\suavizar_fases_por_secuencia.py:136:            a = local[i]["fase"]
  scripts\suavizar_fases_por_secuencia.py:137:            b = local[i + 1]["fase"]
  scripts\suavizar_fases_por_secuencia.py:138:            if a and b and not is_allowed(a, b):
  scripts\suavizar_fases_por_secuencia.py:139:                violations_after += 1
  scripts\suavizar_fases_por_secuencia.py:140:        total_violations_after += violations_after
  scripts\suavizar_fases_por_secuencia.py:141:
  scripts\suavizar_fases_por_secuencia.py:142:        # Apply changes if write
  scripts\suavizar_fases_por_secuencia.py:143:        if write and changes_log:
  scripts\suavizar_fases_por_secuencia.py:144:            for (conv, turno_pk, old_f, new_f) in [c for c in changes_log if c[0] == conv_pk]:
  scripts\suavizar_fases_por_secuencia.py:145:                cur.execute(
> scripts\suavizar_fases_por_secuencia.py:146:                    "UPDATE sa_turnos SET fase=%s, fase_conf=%s, fase_source=%s WHERE turno_pk=%s",
  scripts\suavizar_fases_por_secuencia.py:147:                    (new_f, 0.55, "SMOOTH", turno_pk),
  scripts\suavizar_fases_por_secuencia.py:148:                )
  scripts\suavizar_fases_por_secuencia.py:149:
  scripts\suavizar_fases_por_secuencia.py:150:    if write and total_changes:
  scripts\suavizar_fases_por_secuencia.py:151:        conn.commit()
  scripts\suavizar_fases_por_secuencia.py:152:
  scripts\suavizar_fases_por_secuencia.py:153:    print("--- Suavizado Fases ---")
  scripts\suavizar_fases_por_secuencia.py:154:    print(f"Ejecución: {ejecucion_id}")
  scripts\suavizar_fases_por_secuencia.py:155:    print(f"Violaciones antes: {total_violations_before}")
  scripts\suavizar_fases_por_secuencia.py:156:    print(f"Violaciones después: {total_violations_after}")
  scripts\suavizar_fases_por_secuencia.py:157:    print(f"Cambios aplicados: {total_changes}")
  scripts\suavizar_fases_por_secuencia.py:158:    return {
  scripts\suavizar_fases_por_secuencia.py:159:        "violations_before": total_violations_before,
  scripts\suavizar_fases_por_secuencia.py:160:        "violations_after": total_violations_after,
  scripts\suavizar_fases_por_secuencia.py:161:        "changes": total_changes,
  scripts\suavizar_fases_por_secuencia.py:162:    }
  scripts\suavizar_fases_por_secuencia.py:163:
  scripts\suavizar_fases_por_secuencia.py:164:
  scripts\suavizar_fases_por_secuencia.py:165:def main():
  scripts\suavizar_fases_por_secuencia.py:166:    ap = argparse.ArgumentParser(description="Suaviza fases por secuencia para reducir transiciones ilegales")
  scripts\suavizar_fases_por_secuencia.py:167:    ap.add_argument("--ejecucion_id", type=int, required=True)
  scripts\suavizar_fases_por_secuencia.py:168:    ap.add_argument("--conf_min", type=float, default=0.40)
  scripts\suavizar_fases_por_secuencia.py:169:    ap.add_argument("--write", action="store_true")
  scripts\suavizar_fases_por_secuencia.py:170:    ap.add_argument("--verbose", action="store_true")
  scripts\suavizar_fases_por_secuencia.py:171:    ap.add_argument("--config", default="config.ini")
  scripts\suavizar_fases_por_secuencia.py:172:    args = ap.parse_args()
  scripts\suavizar_fases_por_secuencia.py:173:
  scripts\suavizar_fases_por_secuencia.py:174:    cfg = load_config(args.config)
  scripts\suavizar_fases_por_secuencia.py:175:    conn = get_conn(cfg)
  scripts\suavizar_fases_por_secuencia.py:176:    try:
  scripts\suavizar_fases_por_secuencia.py:177:        suavizar_fases_por_secuencia(conn, args.ejecucion_id, conf_min=args.conf_min, write=args.write, verbose=args.verbose)
  scripts\suavizar_fases_por_secuencia.py:178:    finally:
  scripts\suavizar_fases_por_secuencia.py:179:        if conn and conn.is_connected():
  scripts\suavizar_fases_por_secuencia.py:180:            conn.close()
  scripts\suavizar_fases_por_secuencia.py:181:
  scripts\suavizar_fases_por_secuencia.py:182:
  scripts\suavizar_fases_por_secuencia.py:183:if __name__ == "__main__":
  scripts\suavizar_fases_por_secuencia.py:184:    main()


